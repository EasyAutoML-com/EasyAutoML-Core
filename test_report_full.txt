============================= test session starts =============================
platform win32 -- Python 3.11.9, pytest-8.4.2, pluggy-1.6.0 -- C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Scripts\python.exe
cachedir: .pytest_cache
django: version: 5.2.3
rootdir: C:\Users\Administrator\Documents\Repo-EAML-Core
configfile: pytest.ini
plugins: anyio-4.9.0, langsmith-0.4.1, django-4.11.1
collecting ... collected 204 items

tests/Tests All AI modules/unit/test_database_integrity.py::test_pretest_03_django_db_connection PASSED [  0%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_init PASSED [  0%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_machine_model PASSED [  1%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_user_model PASSED [  1%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_team_model PASSED [  2%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_logger PASSED [  2%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_logger_functionality PASSED [  3%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_all_models_access PASSED [  3%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_objects_interface PASSED [  4%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_queryset_methods PASSED [  4%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_field_access PASSED [  5%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_singleton_behavior PASSED [  5%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_meta_access PASSED [  6%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_string_representation PASSED [  6%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_verbose_names PASSED [  7%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_ordering PASSED [  7%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_permissions PASSED [  8%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_constraints PASSED [  8%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_indexes PASSED [  9%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_unique_together PASSED [  9%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_index_together PASSED [ 10%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_create_configuration PASSED [ 10%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_load_configuration PASSED [ 11%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_encode_for_ai PASSED [ 11%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_decode_from_ai PASSED [ 12%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_encode_decode_roundtrip PASSED [ 12%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_save_configuration PASSED [ 13%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_configuration_serialization PASSED [ 13%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_invalid_dataframe_type PASSED [ 14%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_with_different_data_types PASSED [ 14%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_get_encoded_for_ai_columns_names_by_the_pre_encoded_column_name PASSED [ 15%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_create_minimum_configuration PASSED [ 15%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_load_configuration PASSED [ 16%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_save_configuration PASSED [ 16%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_get_all_column_datas_infos PASSED [ 17%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_fet_activation_logic PASSED [ 17%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_cost_per_columns PASSED [ 18%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_invalid_parameters PASSED [ 18%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_with_different_data_types PASSED [ 19%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_find_delay_tracking PASSED [ 19%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_set_this_fec_in_columns_configuration PASSED [ 20%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_store_this_fec_to_fet_list_configuration PASSED [ 20%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_get_column_data_overview_information PASSED [ 21%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_create_minimum_configuration PASSED [ 21%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_load_configuration PASSED [ 22%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_save_configuration PASSED [ 22%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_importance_evaluation_structure PASSED [ 23%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_input_output_columns_separation PASSED [ 23%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_find_delay_tracking PASSED [ 24%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_invalid_parameters PASSED [ 24%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_with_different_data_types PASSED [ 25%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_minimum_configuration_equal_importance PASSED [ 25%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_with_numeric_data PASSED [ 25%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_create_with_dataframe PASSED [ 26%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_save_and_load_by_id PASSED [ 26%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_load_by_name PASSED [ 27%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_get_random_dataframe PASSED [ 27%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_config_ready_flags PASSED [ 28%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_clear_config_methods PASSED [ 28%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_repr PASSED [ 29%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_with_machine_level PASSED [ 29%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_access_check PASSED [ 30%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_get_last_id PASSED [ 30%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_create_both_tables PASSED [ 31%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_read PASSED [ 31%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_update PASSED [ 32%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_delete_all PASSED [ 32%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_append PASSED [ 33%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_mark PASSED [ 33%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_read PASSED [ 34%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_append PASSED [ 34%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_mark PASSED [ 35%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_mark_all_IsForLearning_as_IsLearned PASSED [ 35%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_update PASSED [ 36%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_count PASSED [ 36%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_output_lines_read PASSED [ 37%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_output_lines_append PASSED [ 37%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_output_lines_mark PASSED [ 38%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_output_lines_update PASSED [ 38%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_output_lines_count PASSED [ 39%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_copy PASSED [ 39%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_is_this_machine_exist_and_authorized PASSED [ 40%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_store_error PASSED [ 40%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_store_warning PASSED [ 41%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_get_machine_overview_information PASSED [ 41%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_user_dataframe_format_then_save_in_db PASSED [ 42%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_get_all_encoded_for_ai_columns_names_by_the_pre_encoded_column_name PASSED [ 42%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_get_list_of_columns_name PASSED [ 43%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_scale_loss_to_user_loss PASSED [ 43%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_get_count_of_rows_per_isforflags PASSED [ 44%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_feature_engineering_budget PASSED [ 44%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_with_test_database_content PASSED [ 45%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_create_configuration PASSED [ 45%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_load_configuration PASSED [ 46%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_dataframe_pre_encode PASSED [ 46%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_dataframe_post_decode PASSED [ 47%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_save_configuration PASSED [ 47%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_column_statistics PASSED [ 48%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_json_column_handling PASSED [ 48%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_missing_values_handling PASSED [ 49%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_force_inputs_outputs PASSED [ 49%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_errors_and_warnings PASSED [ 50%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_verify_compatibility_additional_dataframe PASSED [ 50%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_get_parent_of_extended_column PASSED [ 50%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_get_children_of_json_column PASSED [ 51%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoML::test_easy_automl_init PASSED [ 51%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoML::test_easy_automl_predict PASSED [ 52%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoML::test_easy_automl_train PASSED [ 52%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoML::test_easy_automl_get_status FAILED [ 53%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoML::test_easy_automl_with_different_data_types PASSED [ 53%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoML::test_easy_automl_configuration_management PASSED [ 54%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoML::test_easy_automl_error_handling PASSED [ 54%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoML::test_easy_automl_with_numeric_data PASSED [ 55%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_api_init PASSED [ 55%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_api_predict PASSED [ 56%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_api_train PASSED [ 56%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_api_get_status FAILED [ 57%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_api_end_to_end_workflow PASSED [ 57%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_api_with_different_data_types PASSED [ 58%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_api_error_handling PASSED [ 58%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_ready_to_predict PASSED [ 59%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_learn_this_inputs_outputs PASSED [ 59%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_learn_this_part_inputs PASSED [ 60%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_learn_this_part_outputs PASSED [ 60%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_get_experience_data_saved PASSED [ 61%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_get_experiences_not_yet_saved PASSED [ 61%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_get_list_input_columns_names PASSED [ 62%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_set_list_input_columns_names PASSED [ 62%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_get_list_output_columns_names PASSED [ 63%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_set_list_output_columns_names PASSED [ 63%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_save_data PASSED [ 64%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nn_config_create_configuration PASSED [ 64%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nn_config_save_configuration PASSED [ 65%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nnc_adapt_config_to_new_enc_dec PASSED [ 65%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nnc_get_configuration_as_dict PASSED [ 66%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nnc_build_keras_nn_model PASSED [ 66%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nnc_get_user_nn_shape PASSED [ 67%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nnc_get_machine_nn_shape PASSED [ 67%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nnc_get_hidden_layers_count PASSED [ 68%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nnc_get_neurons_percentage PASSED [ 68%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nnc_get_list_of_nn_shape_columns_names PASSED [ 69%]
tests/Tests All AI modules/unit/test_nn_engine.py::TestNNEngine::test_nn_engine_class_methods PASSED [ 69%]
tests/Tests All AI modules/unit/test_nn_engine.py::TestNNEngine::test_nne_machine_nn_engine_configuration_set_starting PASSED [ 70%]
tests/Tests All AI modules/unit/test_nn_engine.py::TestNNEngine::test_nne_machine_nn_engine_configuration_is_configurating PASSED [ 70%]
tests/Tests All AI modules/unit/test_salaries_prediction.py::TestSalariesPrediction::test_salaries_prediction_complete_workflow FAILED [ 71%]
tests/Tests All AI modules/unit/test_salaries_prediction.py::TestSalariesPrediction::test_salaries_prediction_diagnostic_row_count FAILED [ 71%]
tests/Tests All AI modules/unit/test_solution_finder.py::TestSolutionFinder::test_solution_finder_init PASSED [ 72%]
tests/Tests All AI modules/unit/test_solution_finder.py::TestSolutionFinder::test_solution_finder_result_tracking PASSED [ 72%]
tests/Tests All AI modules/unit/test_solution_finder.py::TestSolutionFinder::test_solution_finder_differential_evolution_logic PASSED [ 73%]
tests/Tests All AI modules/unit/test_solution_finder.py::TestSolutionFinder::test_solution_finder_with_different_parameter_types PASSED [ 73%]
tests/Tests All AI modules/unit/test_solution_finder.py::TestSolutionFinder::test_solution_finder_empty_possible_values PASSED [ 74%]
tests/Tests All AI modules/unit/test_solution_finder.py::TestSolutionFinder::test_solution_finder_name_property PASSED [ 74%]
tests/Tests All AI modules/unit/test_solution_finder.py::TestSolutionFinder::test_solution_finder_result_initialization PASSED [ 75%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_init_with_dict PASSED [ 75%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_init_with_dataframe PASSED [ 75%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_eval_basic PASSED [ 76%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_eval_with_list_criteria PASSED [ 76%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_eval_with_numeric_criteria PASSED [ 77%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_eval_with_percentage_weights PASSED [ 77%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_eval_with_target_values PASSED [ 78%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_eval_with_mixed_criteria PASSED [ 78%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_column_types_detection PASSED [ 79%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_invalid_formula PASSED [ 79%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_empty_formula PASSED [ 80%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_eval_with_empty_data PASSED [ 80%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_eval_with_missing_columns PASSED [ 81%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_eval_with_nan_values PASSED [ 81%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_complex_formula PASSED [ 82%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_static_methods PASSED [ 82%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_scored_columns_list PASSED [ 83%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_how_many_columns_having_criteria PASSED [ 83%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_how_many_columns_having_criteria_numeric PASSED [ 84%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_how_many_columns_having_criteria_label PASSED [ 84%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_how_many_columns_having_criteria_list PASSED [ 85%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_get_columns_with_criteria_compare_values PASSED [ 85%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_get_columns_with_criteria_possible_values PASSED [ 86%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_get_columns_with_criteria_boundary_max PASSED [ 86%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_get_columns_with_criteria_boundary_min PASSED [ 87%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_get_columns_with_score PASSED [ 87%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_total_count_of_possible_combinations_of_criteria_values PASSED [ 88%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_get_columns_with_varying PASSED [ 88%]
tests/Tests All AI modules/unit/test_solution_score.py::TestSolutionScore::test_solution_score_get_columns_with_constants PASSED [ 89%]
tests/Tests All AI modules/unit/test_z_machine_1.py::TestMachine1::test_machine_1 FAILED [ 89%]
tests/Tests All AI modules/unit/test_z_machine_2.py::TestMachine2::test_machine_2_experimenter_workflow FAILED [ 90%]
tests/Tests All AI modules/unit/test_z_machine_3.py::TestMachine3::test_json_flattening_and_mdc_configuration PASSED [ 90%]
tests/Tests All AI modules/unit/test_database_integrity.py::test_pretest_00_django_models_import PASSED [ 91%]
tests/Tests All AI modules/unit/test_database_integrity.py::test_pretest_01_django_models_relationships PASSED [ 91%]
tests/Tests All AI modules/unit/test_database_integrity.py::test_pretest_02_database_copy_creation PASSED [ 92%]
tests/Tests All AI modules/unit/test_database_integrity.py::test_database_integrity_check_tables PASSED [ 92%]
tests/Tests All AI modules/unit/test_database_integrity.py::test_database_integrity_check_machine_data PASSED [ 93%]
tests/Tests All AI modules/unit/test_database_integrity.py::test_database_integrity_check_configuration_data PASSED [ 93%]
tests/Tests All AI modules/unit/test_database_integrity.py::test_database_integrity_check_user_and_team PASSED [ 94%]
tests/Tests All AI modules/unit/test_database_integrity.py::test_database_integrity_check_data_lines_tables PASSED [ 94%]
tests/Tests All AI modules/unit/test_database_integrity.py::test_database_integrity_check_constraints PASSED [ 95%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_invalid_machine_type PASSED [ 95%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_invalid_machine_type PASSED [ 96%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_invalid_machine_type PASSED [ 96%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_invalid_parameters PASSED [ 97%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_invalid_machine_type PASSED [ 97%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoML::test_easy_automl_invalid_machine_type PASSED [ 98%]
tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_api_invalid_machine_type PASSED [ 98%]
tests/Tests All AI modules/unit/test_nn_configuration.py::TestNNConfiguration::test_nn_config_invalid_machine_type PASSED [ 99%]
tests/Tests All AI modules/unit/test_nn_engine.py::TestNNEngine::test_nn_engine_invalid_machine_type PASSED [ 99%]
tests/Tests All AI modules/unit/test_solution_finder.py::TestSolutionFinder::test_solution_finder_invalid_parameters PASSED [100%]

================================== FAILURES ===================================
______________ TestMachineEasyAutoML.test_easy_automl_get_status ______________

self = <unit.test_machine_easy_automl.TestMachineEasyAutoML object at 0x00000294948DE110>
db_cleanup = None
simple_dataframe =     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1...314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533
columns_datatype = {'feature1': <DatasetColumnDataType.FLOAT: 2>, 'feature2': <DatasetColumnDataType.FLOAT: 2>, 'feature3': <DatasetColumnDataType.LABEL: 3>, 'target': <DatasetColumnDataType.FLOAT: 2>}
columns_description = {'feature1': 'First feature', 'feature2': 'Second feature', 'feature3': 'Third categorical feature', 'target': 'Target variable'}

    @pytest.mark.django_db
    def test_easy_automl_get_status(self, db_cleanup, simple_dataframe, columns_datatype, columns_description):
        """Test MachineEasyAutoML status checking"""
        machine = Machine(
            "__TEST_UNIT__easy_automl_status",
            simple_dataframe,
            decimal_separator=".",
            date_format="%Y-%m-%d",
            machine_create_user_id=self._get_admin_user().id,
            disable_foreign_key_checking=True
        )
        machine.save_machine_to_db()
    
        # Create MachineEasyAutoML
        easy_automl = MachineEasyAutoML(
            "__TEST_UNIT__easy_automl_status",
            access_user_id=self._get_admin_user().id
        )
    
        # Test status checking
        try:
            status = easy_automl.ready_to_predict()
>           assert isinstance(status, bool)
E           assert False
E            +  where False = isinstance(None, bool)

columns_datatype = {'feature1': <DatasetColumnDataType.FLOAT: 2>,
 'feature2': <DatasetColumnDataType.FLOAT: 2>,
 'feature3': <DatasetColumnDataType.LABEL: 3>,
 'target': <DatasetColumnDataType.FLOAT: 2>}
columns_description = {'feature1': 'First feature',
 'feature2': 'Second feature',
 'feature3': 'Third categorical feature',
 'target': 'Target variable'}
db_cleanup = None
easy_automl = MachineEasyAutoML:__TEST_UNIT__easy_automl_status
machine    = <machine:904:__TEST_UNIT__easy_automl_statu...>
self       = <unit.test_machine_easy_automl.TestMachineEasyAutoML object at 0x00000294948DE110>
simple_dataframe =     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533
status     = None

tests\Tests All AI modules\unit\test_machine_easy_automl.py:288: AssertionError

During handling of the above exception, another exception occurred:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029501D939C0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

cls        = <class '_pytest.runner.CallInfo'>
duration   = Duration(start=Instant(time=1763790913.9899187, perf_count=183130.5597731),
         stop=Instant(time=1763791045.8356383, perf_count=183262.4191085))
excinfo    = <ExceptionInfo AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\...here False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))") tblen=24>
func       = <function call_and_report.<locals>.<lambda> at 0x0000029501D939C0>
instant    = Instant(time=1763790913.9899187, perf_count=183130.5597731)
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
when       = 'call'

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )

item       = <Function test_easy_automl_get_status>
kwds       = {}
runtest_hook = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_easy_automl_get_status>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
kwargs     = {'item': <Function test_easy_automl_get_status>}
self       = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
kwargs = {'item': <Function test_easy_automl_get_status>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
hook_name  = 'pytest_runtest_call'
kwargs     = {'item': <Function test_easy_automl_get_status>}
methods    = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_easy_automl_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()\n +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF58A0>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF58A0>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F27D30>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF58A0>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_easy_automl_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()\n +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF58A0>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF58A0>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F27D30>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF58A0>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>
item = <Function test_easy_automl_get_status>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")
    
        with self._runtest_for(item, "call"):
>           yield

item       = <Function test_easy_automl_get_status>
self       = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\logging.py:850: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_easy_automl_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()\n +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF58A0>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF58A0>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F27D30>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF58A0>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io...._io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_easy_automl_get_status>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

item       = <Function test_easy_automl_get_status>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\capture.py:900: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_easy_automl_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()\n +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF58A0>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF58A0>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F27D30>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF58A0>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_easy_automl_get_status>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

args       = [<Function test_easy_automl_get_status>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x000002951E409B80>
teardown   = <generator object pytest_runtest_call at 0x000002949490AF40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x000002951E409B80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

__tracebackhide__ = True
exc        = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()\n +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
self       = <pluggy._result.Result object at 0x000002951E409B80>
tb         = <traceback object at 0x000002951E40B400>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_result.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_easy_automl_get_status>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

args       = [<Function test_easy_automl_get_status>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x000002951E409B80>
teardown   = <generator object pytest_runtest_call at 0x000002949490AF40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_easy_automl_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()\n +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF58A0>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF58A0>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F27D30>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF58A0>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_easy_automl_get_status>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)
    
        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)
    
        try:
>           return (yield)
                    ^^^^^

item       = <Function test_easy_automl_get_status>
xfailed    = None

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\skipping.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_easy_automl_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()\n +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF58A0>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF58A0>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495F246D0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F27D30>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF58A0>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_easy_automl_get_status>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

item       = <Function test_easy_automl_get_status>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_easy_automl_get_status>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

self       = <Function test_easy_automl_get_status>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:1671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_easy_automl_get_status>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
kwargs     = {'pyfuncitem': <Function test_easy_automl_get_status>}
self       = <HookCaller 'pytest_pyfunc_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
kwargs = {'pyfuncitem': <Function test_easy_automl_get_status>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
hook_name  = 'pytest_pyfunc_call'
kwargs     = {'pyfuncitem': <Function test_easy_automl_get_status>}
methods    = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_easy_automl_get_status>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_easy_automl_get_status>]
caller_kwargs = {'pyfuncitem': <Function test_easy_automl_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()\n +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_easy_automl_get_status>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_easy_automl_get_status>]
caller_kwargs = {'pyfuncitem': <Function test_easy_automl_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()\n +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_easy_automl_get_status>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

funcargs   = {'_dj_autoclear_mailbox': None,
 '_django_clear_site_cache': None,
 '_django_db_marker': None,
 '_django_set_urlconf': None,
 '_django_setup_unittest': None,
 '_fail_for_invalid_template_variable': None,
 '_live_server_helper': None,
 '_template_string_if_invalid_marker': None,
 'columns_datatype': {'feature1': <DatasetColumnDataType.FLOAT: 2>,
                      'feature2': <DatasetColumnDataType.FLOAT: 2>,
                      'feature3': <DatasetColumnDataType.LABEL: 3>,
                      'target': <DatasetColumnDataType.FLOAT: 2>},
 'columns_description': {'feature1': 'First feature',
                         'feature2': 'Second feature',
                         'feature3': 'Third categorical feature',
                         'target': 'Target variable'},
 'db_cleanup': None,
 'django_db_blocker': <pytest_django.plugin.DjangoDbBlocker object at 0x000002940D867690>,
 'django_test_environment': None,
 'monkeypatch': <_pytest.monkeypatch.MonkeyPatch object at 0x0000029520380C10>,
 'request': <FixtureRequest for <Function test_easy_automl_get_status>>,
 'simple_dataframe':     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533}
pyfuncitem = <Function test_easy_automl_get_status>
testargs   = {'columns_datatype': {'feature1': <DatasetColumnDataType.FLOAT: 2>,
                      'feature2': <DatasetColumnDataType.FLOAT: 2>,
                      'feature3': <DatasetColumnDataType.LABEL: 3>,
                      'target': <DatasetColumnDataType.FLOAT: 2>},
 'columns_description': {'feature1': 'First feature',
                         'feature2': 'Second feature',
                         'feature3': 'Third categorical feature',
                         'target': 'Target variable'},
 'db_cleanup': None,
 'simple_dataframe':     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533}
testfunction = <bound method TestMachineEasyAutoML.test_easy_automl_get_status of <unit.test_machine_easy_automl.TestMachineEasyAutoML object at 0x00000294948DE110>>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unit.test_machine_easy_automl.TestMachineEasyAutoML object at 0x00000294948DE110>
db_cleanup = None
simple_dataframe =     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1...314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533
columns_datatype = {'feature1': <DatasetColumnDataType.FLOAT: 2>, 'feature2': <DatasetColumnDataType.FLOAT: 2>, 'feature3': <DatasetColumnDataType.LABEL: 3>, 'target': <DatasetColumnDataType.FLOAT: 2>}
columns_description = {'feature1': 'First feature', 'feature2': 'Second feature', 'feature3': 'Third categorical feature', 'target': 'Target variable'}

    @pytest.mark.django_db
    def test_easy_automl_get_status(self, db_cleanup, simple_dataframe, columns_datatype, columns_description):
        """Test MachineEasyAutoML status checking"""
        machine = Machine(
            "__TEST_UNIT__easy_automl_status",
            simple_dataframe,
            decimal_separator=".",
            date_format="%Y-%m-%d",
            machine_create_user_id=self._get_admin_user().id,
            disable_foreign_key_checking=True
        )
        machine.save_machine_to_db()
    
        # Create MachineEasyAutoML
        easy_automl = MachineEasyAutoML(
            "__TEST_UNIT__easy_automl_status",
            access_user_id=self._get_admin_user().id
        )
    
        # Test status checking
        try:
            status = easy_automl.ready_to_predict()
            assert isinstance(status, bool)
    
        except Exception as e:
            # Status checking should work even if other operations fail
>           assert "status" in str(e).lower()
E           AssertionError: assert 'status' in 'assert false\n +  where false = isinstance(none, bool)'
E            +  where 'assert false\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()
E            +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\n +  where False = isinstance(None, bool)'.lower
E            +      where 'assert False\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\n +  where False = isinstance(None, bool)'))

columns_datatype = {'feature1': <DatasetColumnDataType.FLOAT: 2>,
 'feature2': <DatasetColumnDataType.FLOAT: 2>,
 'feature3': <DatasetColumnDataType.LABEL: 3>,
 'target': <DatasetColumnDataType.FLOAT: 2>}
columns_description = {'feature1': 'First feature',
 'feature2': 'Second feature',
 'feature3': 'Third categorical feature',
 'target': 'Target variable'}
db_cleanup = None
easy_automl = MachineEasyAutoML:__TEST_UNIT__easy_automl_status
machine    = <machine:904:__TEST_UNIT__easy_automl_statu...>
self       = <unit.test_machine_easy_automl.TestMachineEasyAutoML object at 0x00000294948DE110>
simple_dataframe =     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533
status     = None

tests\Tests All AI modules\unit\test_machine_easy_automl.py:292: AssertionError
---------------------------- Captured stderr call -----------------------------
[31mERROR   |<frozen runpy>|Invalid date_format: '%Y-%m-%d'. Must be one of ('DMY', 'MDY', 'YMD')[0m
[31mERROR   |<frozen runpy>|Invalid date_format: '%Y-%m-%d'. Must be one of ('DMY', 'MDY', 'YMD')[0m
[34mDEBUG   |<frozen runpy>|Creation __TEST_UNIT__easy_automl_status by Dataset [0m
[34mDEBUG   |<frozen runpy>|Creating DFR from dataframe , shape:(20, 4)[0m
[34mDEBUG   |<frozen runpy>|Analysing column : feature1 -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : feature2 -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : feature3 -> DatasetColumnDataType.LABEL[0m
[34mDEBUG   |<frozen runpy>|Analysing column : target -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Reformat DF : 20 rows X 4 cols [0m
[31mERROR   |<frozen runpy>|Invalid date_format: '%Y-%m-%d'. Must be one of ('DMY', 'MDY', 'YMD')[0m
[34mDEBUG   |<frozen runpy>|Creation __TEST_UNIT__easy_automl_status by DFR [0m
[34mDEBUG   |<frozen runpy>|Creation MachineDataConfiguration from user dataset[0m
[34mDEBUG   |<frozen runpy>|MDC saving configuration full[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine: Empty machine> on disk[0m
[34mDEBUG   |<frozen runpy>|Create_data_tables for <machine:904:__TEST_UNIT__easy_automl_statu...> started[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataInputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataInputLines" (
	"Line_ID" BIGINT, 
	feature1 FLOAT, 
	feature2 FLOAT, 
	feature3 TEXT, 
	"IsForLearning" BOOLEAN, 
	"IsForSolving" BOOLEAN, 
	"IsForEvaluation" BOOLEAN, 
	"IsLearned" BOOLEAN, 
	"IsSolved" BOOLEAN
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data input lines was appended. First_new_row_id:1 with arguments:{}[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataOutputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataOutputLines" (
	"Line_ID" BIGINT, 
	target FLOAT
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data output lines was appended[0m
[34mDEBUG   |<frozen runpy>|data_lines_appended     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533 rows, with kwarg:{} [0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_UNIT__easy_automl_statu...> on disk[0m
[34mDEBUG   |<frozen runpy>|Machine created and saved : <machine:904:__TEST_UNIT__easy_automl_statu...>[0m
[34mDEBUG   |<frozen runpy>|Saving <machine:904:__TEST_UNIT__easy_automl_statu...> on disk[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_UNIT__easy_automl_statu...> on disk[0m
__________ TestMachineEasyAutoMLAPI.test_easy_automl_api_get_status ___________

self = <unit.test_machine_easy_automl.TestMachineEasyAutoMLAPI object at 0x00000294948D4F90>
db_cleanup = None
simple_dataframe =     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1...314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533
columns_datatype = {'feature1': <DatasetColumnDataType.FLOAT: 2>, 'feature2': <DatasetColumnDataType.FLOAT: 2>, 'feature3': <DatasetColumnDataType.LABEL: 3>, 'target': <DatasetColumnDataType.FLOAT: 2>}
columns_description = {'feature1': 'First feature', 'feature2': 'Second feature', 'feature3': 'Third categorical feature', 'target': 'Target variable'}

    @pytest.mark.django_db
    def test_easy_automl_api_get_status(self, db_cleanup, simple_dataframe, columns_datatype, columns_description):
        """Test MachineEasyAutoML status checking"""
        machine = Machine(
            "__TEST_UNIT__easy_automl_api_status",
            simple_dataframe,
            decimal_separator=".",
            date_format="%Y-%m-%d",
            machine_create_user_id=self._get_admin_user().id,
            disable_foreign_key_checking=True
        )
        machine.save_machine_to_db()
    
        # Create MachineEasyAutoML
        easy_automl_api = MachineEasyAutoML(
            "__TEST_UNIT__easy_automl_api_status",
            access_user_id=self._get_admin_user().id
        )
    
        # Test status checking
        try:
            status = easy_automl_api.ready_to_predict()
>           assert isinstance(status, bool)
E           assert False
E            +  where False = isinstance(None, bool)

columns_datatype = {'feature1': <DatasetColumnDataType.FLOAT: 2>,
 'feature2': <DatasetColumnDataType.FLOAT: 2>,
 'feature3': <DatasetColumnDataType.LABEL: 3>,
 'target': <DatasetColumnDataType.FLOAT: 2>}
columns_description = {'feature1': 'First feature',
 'feature2': 'Second feature',
 'feature3': 'Third categorical feature',
 'target': 'Target variable'}
db_cleanup = None
easy_automl_api = MachineEasyAutoML:__TEST_UNIT__easy_automl_api_status
machine    = <machine:904:__TEST_UNIT__easy_automl_api_s...>
self       = <unit.test_machine_easy_automl.TestMachineEasyAutoMLAPI object at 0x00000294948D4F90>
simple_dataframe =     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533
status     = None

tests\Tests All AI modules\unit\test_machine_easy_automl.py:544: AssertionError

During handling of the above exception, another exception occurred:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029495F0D580>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

cls        = <class '_pytest.runner.CallInfo'>
duration   = Duration(start=Instant(time=1763791969.8227875, perf_count=184186.3922845),
         stop=Instant(time=1763792103.1267066, perf_count=184319.7017203))
excinfo    = <ExceptionInfo AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\...here False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))") tblen=24>
func       = <function call_and_report.<locals>.<lambda> at 0x0000029495F0D580>
instant    = Instant(time=1763791969.8227875, perf_count=184186.3922845)
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
when       = 'call'

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )

item       = <Function test_easy_automl_api_get_status>
kwds       = {}
runtest_hook = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_easy_automl_api_get_status>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
kwargs     = {'item': <Function test_easy_automl_api_get_status>}
self       = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
kwargs = {'item': <Function test_easy_automl_api_get_status>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
hook_name  = 'pytest_runtest_call'
kwargs     = {'item': <Function test_easy_automl_api_get_status>}
methods    = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_easy_automl_api_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()\n +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E2BE20>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E2BE20>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F244F0>,
 <generator object run_old_style_hookwrapper at 0x00000294964C7AC0>,
 <generator object pytest_runtest_call at 0x0000029495E2BE20>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_easy_automl_api_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()\n +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E2BE20>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E2BE20>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F244F0>,
 <generator object run_old_style_hookwrapper at 0x00000294964C7AC0>,
 <generator object pytest_runtest_call at 0x0000029495E2BE20>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>
item = <Function test_easy_automl_api_get_status>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")
    
        with self._runtest_for(item, "call"):
>           yield

item       = <Function test_easy_automl_api_get_status>
self       = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\logging.py:850: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_easy_automl_api_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()\n +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E2BE20>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E2BE20>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F244F0>,
 <generator object run_old_style_hookwrapper at 0x00000294964C7AC0>,
 <generator object pytest_runtest_call at 0x0000029495E2BE20>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io...._io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_easy_automl_api_get_status>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

item       = <Function test_easy_automl_api_get_status>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\capture.py:900: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_easy_automl_api_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()\n +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E2BE20>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E2BE20>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F244F0>,
 <generator object run_old_style_hookwrapper at 0x00000294964C7AC0>,
 <generator object pytest_runtest_call at 0x0000029495E2BE20>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_easy_automl_api_get_status>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

args       = [<Function test_easy_automl_api_get_status>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x000002952034CD40>
teardown   = <generator object pytest_runtest_call at 0x0000029495F1DC40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x000002952034CD40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

__tracebackhide__ = True
exc        = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()\n +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
self       = <pluggy._result.Result object at 0x000002952034CD40>
tb         = <traceback object at 0x000002952034D500>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_result.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_easy_automl_api_get_status>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

args       = [<Function test_easy_automl_api_get_status>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x000002952034CD40>
teardown   = <generator object pytest_runtest_call at 0x0000029495F1DC40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_easy_automl_api_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()\n +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E2BE20>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E2BE20>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F244F0>,
 <generator object run_old_style_hookwrapper at 0x00000294964C7AC0>,
 <generator object pytest_runtest_call at 0x0000029495E2BE20>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_easy_automl_api_get_status>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)
    
        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)
    
        try:
>           return (yield)
                    ^^^^^

item       = <Function test_easy_automl_api_get_status>
xfailed    = None

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\skipping.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_easy_automl_api_get_status>]
caller_kwargs = {'item': <Function test_easy_automl_api_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()\n +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E2BE20>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E2BE20>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF7970>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495F244F0>,
 <generator object run_old_style_hookwrapper at 0x00000294964C7AC0>,
 <generator object pytest_runtest_call at 0x0000029495E2BE20>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_easy_automl_api_get_status>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

item       = <Function test_easy_automl_api_get_status>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_easy_automl_api_get_status>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

self       = <Function test_easy_automl_api_get_status>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:1671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_easy_automl_api_get_status>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
kwargs     = {'pyfuncitem': <Function test_easy_automl_api_get_status>}
self       = <HookCaller 'pytest_pyfunc_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
kwargs = {'pyfuncitem': <Function test_easy_automl_api_get_status>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
hook_name  = 'pytest_pyfunc_call'
kwargs     = {'pyfuncitem': <Function test_easy_automl_api_get_status>}
methods    = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_easy_automl_api_get_status>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_easy_automl_api_get_status>]
caller_kwargs = {'pyfuncitem': <Function test_easy_automl_api_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()\n +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_easy_automl_api_get_status>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_easy_automl_api_get_status>]
caller_kwargs = {'pyfuncitem': <Function test_easy_automl_api_get_status>}
exception  = AssertionError("assert 'status' in 'assert false\\n +  where false = isinstance(none, bool)'\n +  where 'assert false\\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()\n +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\\n +  where False = isinstance(None, bool)'.lower\n +      where 'assert False\\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\\n +  where False = isinstance(None, bool)'))")
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_easy_automl_api_get_status>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

funcargs   = {'_dj_autoclear_mailbox': None,
 '_django_clear_site_cache': None,
 '_django_db_marker': None,
 '_django_set_urlconf': None,
 '_django_setup_unittest': None,
 '_fail_for_invalid_template_variable': None,
 '_live_server_helper': None,
 '_template_string_if_invalid_marker': None,
 'columns_datatype': {'feature1': <DatasetColumnDataType.FLOAT: 2>,
                      'feature2': <DatasetColumnDataType.FLOAT: 2>,
                      'feature3': <DatasetColumnDataType.LABEL: 3>,
                      'target': <DatasetColumnDataType.FLOAT: 2>},
 'columns_description': {'feature1': 'First feature',
                         'feature2': 'Second feature',
                         'feature3': 'Third categorical feature',
                         'target': 'Target variable'},
 'db_cleanup': None,
 'django_db_blocker': <pytest_django.plugin.DjangoDbBlocker object at 0x000002940D867690>,
 'django_test_environment': None,
 'monkeypatch': <_pytest.monkeypatch.MonkeyPatch object at 0x0000029502F95710>,
 'request': <FixtureRequest for <Function test_easy_automl_api_get_status>>,
 'simple_dataframe':     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533}
pyfuncitem = <Function test_easy_automl_api_get_status>
testargs   = {'columns_datatype': {'feature1': <DatasetColumnDataType.FLOAT: 2>,
                      'feature2': <DatasetColumnDataType.FLOAT: 2>,
                      'feature3': <DatasetColumnDataType.LABEL: 3>,
                      'target': <DatasetColumnDataType.FLOAT: 2>},
 'columns_description': {'feature1': 'First feature',
                         'feature2': 'Second feature',
                         'feature3': 'Third categorical feature',
                         'target': 'Target variable'},
 'db_cleanup': None,
 'simple_dataframe':     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533}
testfunction = <bound method TestMachineEasyAutoMLAPI.test_easy_automl_api_get_status of <unit.test_machine_easy_automl.TestMachineEasyAutoMLAPI object at 0x00000294948D4F90>>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unit.test_machine_easy_automl.TestMachineEasyAutoMLAPI object at 0x00000294948D4F90>
db_cleanup = None
simple_dataframe =     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1...314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533
columns_datatype = {'feature1': <DatasetColumnDataType.FLOAT: 2>, 'feature2': <DatasetColumnDataType.FLOAT: 2>, 'feature3': <DatasetColumnDataType.LABEL: 3>, 'target': <DatasetColumnDataType.FLOAT: 2>}
columns_description = {'feature1': 'First feature', 'feature2': 'Second feature', 'feature3': 'Third categorical feature', 'target': 'Target variable'}

    @pytest.mark.django_db
    def test_easy_automl_api_get_status(self, db_cleanup, simple_dataframe, columns_datatype, columns_description):
        """Test MachineEasyAutoML status checking"""
        machine = Machine(
            "__TEST_UNIT__easy_automl_api_status",
            simple_dataframe,
            decimal_separator=".",
            date_format="%Y-%m-%d",
            machine_create_user_id=self._get_admin_user().id,
            disable_foreign_key_checking=True
        )
        machine.save_machine_to_db()
    
        # Create MachineEasyAutoML
        easy_automl_api = MachineEasyAutoML(
            "__TEST_UNIT__easy_automl_api_status",
            access_user_id=self._get_admin_user().id
        )
    
        # Test status checking
        try:
            status = easy_automl_api.ready_to_predict()
            assert isinstance(status, bool)
    
        except Exception as e:
            # Status checking should work
>           assert "status" in str(e).lower()
E           AssertionError: assert 'status' in 'assert false\n +  where false = isinstance(none, bool)'
E            +  where 'assert false\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()
E            +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\n +  where False = isinstance(None, bool)'.lower
E            +      where 'assert False\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\n +  where False = isinstance(None, bool)'))

columns_datatype = {'feature1': <DatasetColumnDataType.FLOAT: 2>,
 'feature2': <DatasetColumnDataType.FLOAT: 2>,
 'feature3': <DatasetColumnDataType.LABEL: 3>,
 'target': <DatasetColumnDataType.FLOAT: 2>}
columns_description = {'feature1': 'First feature',
 'feature2': 'Second feature',
 'feature3': 'Third categorical feature',
 'target': 'Target variable'}
db_cleanup = None
easy_automl_api = MachineEasyAutoML:__TEST_UNIT__easy_automl_api_status
machine    = <machine:904:__TEST_UNIT__easy_automl_api_s...>
self       = <unit.test_machine_easy_automl.TestMachineEasyAutoMLAPI object at 0x00000294948D4F90>
simple_dataframe =     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533
status     = None

tests\Tests All AI modules\unit\test_machine_easy_automl.py:548: AssertionError
---------------------------- Captured stderr call -----------------------------
[31mERROR   |<frozen runpy>|Invalid date_format: '%Y-%m-%d'. Must be one of ('DMY', 'MDY', 'YMD')[0m
[31mERROR   |<frozen runpy>|Invalid date_format: '%Y-%m-%d'. Must be one of ('DMY', 'MDY', 'YMD')[0m
[34mDEBUG   |<frozen runpy>|Creation __TEST_UNIT__easy_automl_api_status by Dataset [0m
[34mDEBUG   |<frozen runpy>|Creating DFR from dataframe , shape:(20, 4)[0m
[34mDEBUG   |<frozen runpy>|Analysing column : feature1 -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : feature2 -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : feature3 -> DatasetColumnDataType.LABEL[0m
[34mDEBUG   |<frozen runpy>|Analysing column : target -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Reformat DF : 20 rows X 4 cols [0m
[31mERROR   |<frozen runpy>|Invalid date_format: '%Y-%m-%d'. Must be one of ('DMY', 'MDY', 'YMD')[0m
[34mDEBUG   |<frozen runpy>|Creation __TEST_UNIT__easy_automl_api_status by DFR [0m
[34mDEBUG   |<frozen runpy>|Creation MachineDataConfiguration from user dataset[0m
[34mDEBUG   |<frozen runpy>|MDC saving configuration full[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine: Empty machine> on disk[0m
[34mDEBUG   |<frozen runpy>|Create_data_tables for <machine:904:__TEST_UNIT__easy_automl_api_s...> started[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataInputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataInputLines" (
	"Line_ID" BIGINT, 
	feature1 FLOAT, 
	feature2 FLOAT, 
	feature3 TEXT, 
	"IsForLearning" BOOLEAN, 
	"IsForSolving" BOOLEAN, 
	"IsForEvaluation" BOOLEAN, 
	"IsLearned" BOOLEAN, 
	"IsSolved" BOOLEAN
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data input lines was appended. First_new_row_id:1 with arguments:{}[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataOutputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataOutputLines" (
	"Line_ID" BIGINT, 
	target FLOAT
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data output lines was appended[0m
[34mDEBUG   |<frozen runpy>|data_lines_appended     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533 rows, with kwarg:{} [0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_UNIT__easy_automl_api_s...> on disk[0m
[34mDEBUG   |<frozen runpy>|Machine created and saved : <machine:904:__TEST_UNIT__easy_automl_api_s...>[0m
[34mDEBUG   |<frozen runpy>|Saving <machine:904:__TEST_UNIT__easy_automl_api_s...> on disk[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_UNIT__easy_automl_api_s...> on disk[0m
______ TestSalariesPrediction.test_salaries_prediction_complete_workflow ______

self = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
>               return self.cursor.execute(sql)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

ignored_wrapper_args = (False,
 {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
  'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>})
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x000002952030B920>
query = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, query, params=None):
        if params is None:
>           return super().execute(query)
                   ^^^^^^^^^^^^^^^^^^^^^^
E           sqlite3.OperationalError: no such column: SepalLengthCm

__class__  = <class 'django.db.backends.sqlite3.base.SQLiteCursorWrapper'>
params     = None
query      = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')
self       = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x000002952030B920>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\sqlite3\base.py:356: OperationalError

The above exception was the direct cause of the following exception:

self = <pandas.io.sql.SQLiteDatabase object at 0x000002951384AF10>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql: str | Select | TextClause, params=None):
        if not isinstance(sql, str):
            raise TypeError("Query must be a string unless using sqlalchemy.")
        args = [] if params is None else [params]
        cur = self.con.cursor()
        try:
>           cur.execute(sql, *args)

args       = []
cur        = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
ex         = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
params     = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x000002951384AF10>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2664: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql, params=None):
>       return self._execute_with_wrappers(
            sql, params, many=False, executor=self._execute
        )

params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None, many = False
executor = <bound method CursorWrapper._execute of <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>>

    def _execute_with_wrappers(self, sql, params, many, executor):
        context = {"connection": self.db, "cursor": self}
        for wrapper in reversed(self.db.execute_wrappers):
            executor = functools.partial(wrapper, executor)
>       return executor(sql, params, many, context)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

context    = {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
 'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>}
executor   = <bound method CursorWrapper._execute of <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>>
many       = False
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
>       with self.db.wrap_database_errors:

ignored_wrapper_args = (False,
 {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
  'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>})
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.utils.DatabaseErrorWrapper object at 0x0000029492DCD2D0>
exc_type = <class 'sqlite3.OperationalError'>
exc_value = OperationalError('no such column: SepalLengthCm')
traceback = <traceback object at 0x000002951384A8C0>

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is None:
            return
        for dj_exc_type in (
            DataError,
            OperationalError,
            IntegrityError,
            InternalError,
            ProgrammingError,
            NotSupportedError,
            DatabaseError,
            InterfaceError,
            Error,
        ):
            db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__)
            if issubclass(exc_type, db_exc_type):
                dj_exc_value = dj_exc_type(*exc_value.args)
                # Only set the 'errors_occurred' flag for errors that may make
                # the connection unusable.
                if dj_exc_type not in (DataError, IntegrityError):
                    self.wrapper.errors_occurred = True
>               raise dj_exc_value.with_traceback(traceback) from exc_value

db_exc_type = <class 'sqlite3.OperationalError'>
dj_exc_type = <class 'django.db.utils.OperationalError'>
dj_exc_value = OperationalError('no such column: SepalLengthCm')
exc_type   = <class 'sqlite3.OperationalError'>
exc_value  = OperationalError('no such column: SepalLengthCm')
self       = <django.db.utils.DatabaseErrorWrapper object at 0x0000029492DCD2D0>
traceback  = <traceback object at 0x000002951384A8C0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\utils.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
>               return self.cursor.execute(sql)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

ignored_wrapper_args = (False,
 {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
  'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>})
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x000002952030B920>
query = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, query, params=None):
        if params is None:
>           return super().execute(query)
                   ^^^^^^^^^^^^^^^^^^^^^^
E           django.db.utils.OperationalError: no such column: SepalLengthCm

__class__  = <class 'django.db.backends.sqlite3.base.SQLiteCursorWrapper'>
params     = None
query      = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')
self       = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x000002952030B920>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\sqlite3\base.py:356: OperationalError

During handling of the above exception, another exception occurred:

self = <pandas.io.sql.SQLiteDatabase object at 0x000002951384AF10>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql: str | Select | TextClause, params=None):
        if not isinstance(sql, str):
            raise TypeError("Query must be a string unless using sqlalchemy.")
        args = [] if params is None else [params]
        cur = self.con.cursor()
        try:
            cur.execute(sql, *args)
            return cur
        except Exception as exc:
            try:
>               self.con.rollback()

args       = []
cur        = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
ex         = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
params     = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x000002951384AF10>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = (<DatabaseWrapper vendor='sqlite' alias='default'>,), kwargs = {}

    @wraps(func)
    def inner(*args, **kwargs):
        # Detect a running event loop in this thread.
        try:
            get_running_loop()
        except RuntimeError:
            pass
        else:
            if not os.environ.get("DJANGO_ALLOW_ASYNC_UNSAFE"):
                raise SynchronousOnlyOperation(message)
        # Pass onward.
>       return func(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^

args       = (<DatabaseWrapper vendor='sqlite' alias='default'>,)
func       = <function BaseDatabaseWrapper.rollback at 0x000002943E4C9260>
kwargs     = {}
message    = 'You cannot call this from an async context - use a thread or sync_to_async.'

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\utils\asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DatabaseWrapper vendor='sqlite' alias='default'>

    @async_unsafe
    def rollback(self):
        """Roll back a transaction and reset the dirty flag."""
        self.validate_thread_sharing()
>       self.validate_no_atomic_block()

self       = <DatabaseWrapper vendor='sqlite' alias='default'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\base\base.py:336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DatabaseWrapper vendor='sqlite' alias='default'>

    def validate_no_atomic_block(self):
        """Raise an error if an atomic block is active."""
        if self.in_atomic_block:
>           raise TransactionManagementError(
                "This is forbidden when an 'atomic' block is active."
            )
E           django.db.transaction.TransactionManagementError: This is forbidden when an 'atomic' block is active.

self       = <DatabaseWrapper vendor='sqlite' alias='default'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\base\base.py:515: TransactionManagementError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029495F0C720>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

cls        = <class '_pytest.runner.CallInfo'>
duration   = Duration(start=Instant(time=1763794481.9942923, perf_count=186698.5638079),
         stop=Instant(time=1763794614.3620968, perf_count=186830.9316196))
excinfo    = <ExceptionInfo DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Spec...4_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback') tblen=32>
func       = <function call_and_report.<locals>.<lambda> at 0x0000029495F0C720>
instant    = Instant(time=1763794481.9942923, perf_count=186698.5638079)
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
when       = 'call'

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )

item       = <Function test_salaries_prediction_complete_workflow>
kwds       = {}
runtest_hook = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
kwargs     = {'item': <Function test_salaries_prediction_complete_workflow>}
self       = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
hook_name  = 'pytest_runtest_call'
kwargs     = {'item': <Function test_salaries_prediction_complete_workflow>}
methods    = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_complete_workflow>]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E76B60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E76B60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495E758A0>,
 <generator object run_old_style_hookwrapper at 0x00000294965B8280>,
 <generator object pytest_runtest_call at 0x0000029495E76B60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_complete_workflow>]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E76B60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E76B60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495E758A0>,
 <generator object run_old_style_hookwrapper at 0x00000294965B8280>,
 <generator object pytest_runtest_call at 0x0000029495E76B60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>
item = <Function test_salaries_prediction_complete_workflow>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")
    
        with self._runtest_for(item, "call"):
>           yield

item       = <Function test_salaries_prediction_complete_workflow>
self       = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\logging.py:850: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_complete_workflow>]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E76B60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E76B60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495E758A0>,
 <generator object run_old_style_hookwrapper at 0x00000294965B8280>,
 <generator object pytest_runtest_call at 0x0000029495E76B60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io...._io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_salaries_prediction_complete_workflow>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

item       = <Function test_salaries_prediction_complete_workflow>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\capture.py:900: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_complete_workflow>]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E76B60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E76B60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495E758A0>,
 <generator object run_old_style_hookwrapper at 0x00000294965B8280>,
 <generator object pytest_runtest_call at 0x0000029495E76B60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_salaries_prediction_complete_workflow>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

args       = [<Function test_salaries_prediction_complete_workflow>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x00000295203414C0>
teardown   = <generator object pytest_runtest_call at 0x0000029495F1F840>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x00000295203414C0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

__tracebackhide__ = True
exc        = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
self       = <pluggy._result.Result object at 0x00000295203414C0>
tb         = <traceback object at 0x0000029520343A40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_result.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_salaries_prediction_complete_workflow>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

args       = [<Function test_salaries_prediction_complete_workflow>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x00000295203414C0>
teardown   = <generator object pytest_runtest_call at 0x0000029495F1F840>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_complete_workflow>]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E76B60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E76B60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495E758A0>,
 <generator object run_old_style_hookwrapper at 0x00000294965B8280>,
 <generator object pytest_runtest_call at 0x0000029495E76B60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_salaries_prediction_complete_workflow>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)
    
        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)
    
        try:
>           return (yield)
                    ^^^^^

item       = <Function test_salaries_prediction_complete_workflow>
xfailed    = None

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\skipping.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_complete_workflow>]
caller_kwargs = {'item': <Function test_salaries_prediction_complete_workflow>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495E76B60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495E76B60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495E765C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495E758A0>,
 <generator object run_old_style_hookwrapper at 0x00000294965B8280>,
 <generator object pytest_runtest_call at 0x0000029495E76B60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_salaries_prediction_complete_workflow>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

item       = <Function test_salaries_prediction_complete_workflow>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_salaries_prediction_complete_workflow>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

self       = <Function test_salaries_prediction_complete_workflow>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:1671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_salaries_prediction_complete_workflow>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
kwargs     = {'pyfuncitem': <Function test_salaries_prediction_complete_workflow>}
self       = <HookCaller 'pytest_pyfunc_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
kwargs = {'pyfuncitem': <Function test_salaries_prediction_complete_workflow>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
hook_name  = 'pytest_pyfunc_call'
kwargs     = {'pyfuncitem': <Function test_salaries_prediction_complete_workflow>}
methods    = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_salaries_prediction_complete_workflow>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_complete_workflow>]
caller_kwargs = {'pyfuncitem': <Function test_salaries_prediction_complete_workflow>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_salaries_prediction_complete_workflow>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_complete_workflow>]
caller_kwargs = {'pyfuncitem': <Function test_salaries_prediction_complete_workflow>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_salaries_prediction_complete_workflow>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

funcargs   = {'_dj_autoclear_mailbox': None,
 '_django_clear_site_cache': None,
 '_django_db_marker': None,
 '_django_set_urlconf': None,
 '_django_setup_unittest': None,
 '_fail_for_invalid_template_variable': None,
 '_live_server_helper': None,
 '_template_string_if_invalid_marker': None,
 'db_cleanup': None,
 'django_db_blocker': <pytest_django.plugin.DjangoDbBlocker object at 0x000002940D867690>,
 'django_test_environment': None,
 'monkeypatch': <_pytest.monkeypatch.MonkeyPatch object at 0x0000029494813250>,
 'request': <FixtureRequest for <Function test_salaries_prediction_complete_workflow>>,
 'session_test_database': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3',
 'test_database': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3',
 'test_database_source': 'C:\\Users\\Administrator\\Documents\\Repo-EAML-Core\\start_set_databases.sqlite3',
 'test_database_with_verification': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'}
pyfuncitem = <Function test_salaries_prediction_complete_workflow>
testargs   = {'test_database_with_verification': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'}
testfunction = <bound method TestSalariesPrediction.test_salaries_prediction_complete_workflow of <unit.test_salaries_prediction.TestSalariesPrediction object at 0x000002949489E110>>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unit.test_salaries_prediction.TestSalariesPrediction object at 0x000002949489E110>
test_database_with_verification = 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'

    @pytest.mark.django_db
    def test_salaries_prediction_complete_workflow(self, test_database_with_verification):
        """
        Test complete workflow for salaries prediction:
        1. Create machine from CSV file
        2. Create all configurations
        3. Run training
        4. Solve rows 607-608
    
        WHAT THIS TEST DOES:
        - Creates a machine from the salaries prediction CSV file
        - Sets up all required configurations (MDC, ICI, FEC, EncDec, NNConfig)
        - Trains the neural network model
        - Makes predictions for rows 607-608
    
        TEST STEPS:
        1. Read CSV file and create machine
        2. Create NNEngine (which creates all configurations)
        3. Train the model
        4. Read rows 607-608 from CSV
        5. Solve those rows (predict salaries)
        """
        # Step 1: Create machine from CSV file
        # Get the test directory
        # __file__ is in tests/Tests All AI modules/unit/test_salaries_prediction.py
        test_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        csv_file_path = os.path.join(
            test_dir,
            "Test Data - Iris flowers.csv"
        )
    
        # Verify file exists
        assert os.path.exists(csv_file_path), f"CSV file not found at {csv_file_path}"
    
        # Read CSV file using DataFileReader
        # Note: The CSV has an index column (first column is empty/unnamed)
        # DataFileReader should handle this, but we ensure descriptions exist for all columns
        dfr = DataFileReader(
            csv_file_path,
            date_format="MDY",
            decimal_separator=".",
        )
    
        # Ensure all columns in the formatted dataframe have descriptions
        # The DataFileReader might not provide descriptions for all columns
        formatted_df = dfr.get_formatted_user_dataframe
        columns_description = dfr.get_user_columns_description or {}
    
        # Add missing column descriptions
        for col in formatted_df.columns:
            if col not in columns_description:
                columns_description[col] = f"Column {col}"
    
        # Create machine
        # Use dfr.get_user_columns_description directly (same as Create All Tests Machines.py)
        machine_name = "__TEST_UNIT__iris_flowers"
        machine = Machine(
            machine_name,
            dfr=dfr,
            decimal_separator=".",
            date_format="MDY",
            machine_create_user_id=get_admin_user().id,
            machine_create_team_id=1,
            machine_description="Test machine for Iris flowers dataset",
            force_create_with_this_descriptions=columns_description,
            machine_level=1,
            disable_foreign_key_checking=True
        )
    
        # Save machine to database
        machine.save_machine_to_db()
    
        # Verify machine was created
        assert machine.id is not None, "Machine should have a valid ID"
        assert machine.db_machine.machine_name == machine_name
    
        # Ensure super admin user and team exist (use conftest helpers to avoid duplicates)
        # These helpers ensure user id=1 and team id=1 are used
        super_admin = get_admin_user()
        assert super_admin is not None, "Admin user should be created"
    
        # Step 2: Create all configurations by creating NNEngine
        # NNEngine automatically creates all required configurations (MDC, ICI, FEC, EncDec, NNConfig)
>       nn_engine = NNEngine(machine, allow_re_run_configuration=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

col        = 'Species'
columns_description = {'PetalLengthCm': 'input',
 'PetalWidthCm': 'input',
 'SepalLengthCm': 'input',
 'SepalWidthCm': 'input',
 'Species': 'output'}
csv_file_path = ('C:\\Users\\Administrator\\Documents\\Repo-EAML-Core\\tests\\Tests All AI '
 'modules\\Test Data - Iris flowers.csv')
dfr        = <ML.DataFileReader.DataFileReader object at 0x0000029520CC9E10>
formatted_df =      SepalLengthCm  SepalWidthCm  PetalLengthCm  PetalWidthCm         Species
0              5.1           3.5            1.4           0.2     Iris-setosa
1              4.9           3.0            1.4           0.2     Iris-setosa
2              4.7           3.2            1.3           0.2     Iris-setosa
3              4.6           3.1            1.5           0.2     Iris-setosa
4              5.0           3.6            1.4           0.2     Iris-setosa
..             ...           ...            ...           ...             ...
145            6.7           3.0            5.2           2.3  Iris-virginica
146            6.3           2.5            5.0           1.9  Iris-virginica
147            6.5           3.0            5.2           2.0  Iris-virginica
148            6.2           3.4            5.4           2.3  Iris-virginica
149            5.9           3.0            5.1           1.8  Iris-virginica

[150 rows x 5 columns]
machine    = <machine:904:__TEST_UNIT__iris_flowers>
machine_name = '__TEST_UNIT__iris_flowers'
self       = <unit.test_salaries_prediction.TestSalariesPrediction object at 0x000002949489E110>
super_admin = <User: Admin User SuperSuperAdmin@easyautoml.com>
test_database_with_verification = 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'
test_dir   = ('C:\\Users\\Administrator\\Documents\\Repo-EAML-Core\\tests\\Tests All AI '
 'modules')

tests\Tests All AI modules\unit\test_salaries_prediction.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ML.NNEngine.NNEngine object at 0x00000294084EFE10>
machine = <machine:904:__TEST_UNIT__iris_flowers>
allow_re_run_configuration = True

    def __init__( self, machine: Machine, allow_re_run_configuration: bool = False ):
        """
        Create NNEngine or load it from Machine
        If configuration are available inside Machine we use it else we will generate it
    
        :param machine: the machine to work on
        """
        if not isinstance(machine, Machine):
            logger.error( "The constructor argument must have an instance of the machine" )
    
        self._machine = machine
        self._mdc = None
        self._ici = None
        self._fe = None
        self._enc_dec = None
        self._nn_configuration = None
        self._nn_model = None
    
        if IS_RUNNING_IN_DEBUG_MODE:
>           self._init_load_or_create_configuration( allow_re_run_configuration=allow_re_run_configuration )

allow_re_run_configuration = True
machine    = <machine:904:__TEST_UNIT__iris_flowers>
self       = <ML.NNEngine.NNEngine object at 0x00000294084EFE10>

ML\NNEngine.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ML.NNEngine.NNEngine object at 0x00000294084EFE10>
allow_re_run_configuration = True, update_data_infos_stats = False

    def _init_load_or_create_configuration( self , allow_re_run_configuration: bool = False , update_data_infos_stats:bool=False ):
        """
        Create NNEngine or load it from Machine
        If configuration are available inside Machine we use it else we will generate it
    
        All configurations to run NNEngine will be prepared here
        NNEngine need to have all this configurations built : MDC, CI, FE, EncDec, NNConfiguration, NNModel
        We try to use the configuration stored into machine, if not available we will generate the configuration, using best if possible or else doing minimum_default
    
        at each step we load the configuration or we create the configuration and save it into machine object
        only last step : training nn model is not performed here (sometime we need nnengine for performing trial learning)
    
        Some flag can trigger some configuration to be rebuilt : re_run - If one Config need to be rebuilt then all following Config will be cleared and rebuilt
        """
    
        if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"NNEngine initializing (loading and/or creating) all configuration for {self._machine}" )
    
        db_machine = self._machine.db_machine
    
        # MDC and EncDec may load and use the dataset - we cache it for faster
        _c_full_df_user = None
        _c_full_df_pre_encoded = None
    
        if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"NNEngine Starting preparing all configurations. " )
        self.machine_nn_engine_configuration_set_starting( self._machine )
    
        # -----------------------------------------
        #  MDC
        # -----------------------------------------
        if not self._machine.is_config_ready_mdc() or (allow_re_run_configuration and db_machine.machine_is_re_run_mdc):
            _c_full_df_user = self._machine.data_lines_read( ) # we have to use the full dataset because with a subset we could miss some labels or out of bound values
            # We do not indicate what user choose because anyway the dataset is formatted and this 2 parameters are useless : decimal_separator  date_format
            self._mdc = MachineDataConfiguration(
                                                    self._machine,
                                                    _c_full_df_user,
                                                    force_create_with_this_inputs=self._machine.db_machine.mdc_columns_name_input,    # we cannot change this after creation
                                                    force_create_with_this_outputs=self._machine.db_machine.mdc_columns_name_output, # we cannot change this after creation
                                                    columns_type_user_df=self._machine.db_machine.dfr_columns_type_user_df,
                                                    columns_description_user_df= self._machine.db_machine.dfr_columns_description_user_df,
                                                    decimal_separator = ".",
                                                    date_format = "MDY" )
            self._mdc.save_configuration_in_machine( )
            # rerun configuration have been done, we can clear the flag
            db_machine.machine_is_re_run_mdc = False
    
            # configuration regenerated need to force following configurations to be rebuilt too
            self._machine.clear_config_ici( )
            self._machine.clear_config_fe( )
            self._machine.clear_config_enc_dec( )
            self._machine.clear_config_nn_configuration( )
            self._machine.clear_config_nn_model( )
    
        else:
            self._mdc = MachineDataConfiguration(self._machine)
            if update_data_infos_stats:
                _c_full_df_user = self._machine.data_lines_read( )  # we have to use the full dataset because with a subset we could miss some labels or out of bound values
                _c_full_df_pre_encoded = self._mdc.dataframe_pre_encode( _c_full_df_user )
                self._mdc._recalculate_data_infos_stats( _c_full_df_pre_encoded, decimal_separator = ".", date_format = "MDY" )
    
        # -----------------------------------------
        #  Column Importance
        # -----------------------------------------
        from ML.InputsColumnsImportance import InputsColumnsImportance
        if not self._machine.is_config_ready_ici( ) or (allow_re_run_configuration and db_machine.machine_is_re_run_ici):
            if (
                    not self._machine.is_config_ready_fe() or
                    not self._machine.is_config_ready_enc_dec() or
                    not self._machine.is_config_ready_nn_configuration() or
                    not self.is_nn_trained_and_ready()
                ):
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( "unable to do ICI best configuration because fe or encdec or nnconfig are not ready => doing minimum ICI" )
                self._ici = InputsColumnsImportance( self._machine , create_configuration_simple_minimum=True).save_configuration_in_machine()
                db_machine.machine_is_re_run_ici = True
            else:
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( "do ICI best configuration because fe or encdec or nnconfig are ready" )
                self._ici = InputsColumnsImportance( self._machine , create_configuration_best=True, nnengine_for_best_config=self ).save_configuration_in_machine()
                # rerun configuration have been done, we can clear the flag
                db_machine.machine_is_re_run_ici = False
    
            # configuration regenerated need to force following configurations to be rebuilt too
            self._machine.clear_config_fe( )
            self._machine.clear_config_enc_dec( )
            self._machine.clear_config_nn_configuration( )
            self._machine.clear_config_nn_model( )
    
        else:
            # load the configuration ICI by default if no force flag and if not needed by rerun to make configuration
             self._ici = InputsColumnsImportance( self._machine )
    
        # -----------------------------------------
        #  FE
        # -----------------------------------------
        from ML.FeatureEngineeringConfiguration import FeatureEngineeringConfiguration
        if not self._machine.is_config_ready_fe() or (allow_re_run_configuration and db_machine.machine_is_re_run_fe):
            if (
                    not self._machine.is_config_ready_enc_dec() or
                    not self._machine.is_config_ready_nn_configuration()
                    ):
                # generate the configuration FE MINIMUM because we cannot do FE_BEST now
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"generate the configuration FE MINIMUM because we cannot do FE_BEST now" )
                self._fe = FeatureEngineeringConfiguration(
                    machine=self._machine,
                    force_configuration_simple_minimum=True
                    ).save_configuration_in_machine()
                # we will do best FE later
                db_machine.machine_is_re_run_fe = True
            else:
                # generate the configuration FE BEST
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"generate the configuration FE BEST  " )
                db_machine.fe_budget_total = MachineLevel(self._machine).feature_engineering_budget()[1]
                # load (never do best config of course) the nnconfiguration that we will use to evaluate the FEC
                self._nn_configuration = NNConfiguration(self._machine)
                self._fe = FeatureEngineeringConfiguration(
                    machine=self._machine,
                    nn_engine_for_searching_best_config=self,
                    global_dataset_budget=self._machine.db_machine.fe_budget_total,
                    force_configuration_simple_minimum=False,
                    ).save_configuration_in_machine()
                # rerun configuration have been done, we can clear the flag
                db_machine.machine_is_re_run_fe = False
    
            #  configuration regenerated need to force following configurations to be rebuilt too
            self._machine.clear_config_enc_dec( )
            self._machine.clear_config_nn_configuration( )
            self._machine.clear_config_nn_model( )
    
        else:
            # load the configuration FE
            self._fe = FeatureEngineeringConfiguration(self._machine)
    
    
        # -----------------------------------------
        #  EncDec
        # -----------------------------------------
        if not self._machine.is_config_ready_enc_dec( ) or (allow_re_run_configuration and db_machine.machine_is_re_run_enc_dec):
            # generate configuration encdec
            if _c_full_df_pre_encoded is None:
                if _c_full_df_user is None:
>                   _c_full_df_user = self._machine.data_lines_read( ) # we have to use the full dataset because with a subset we could miss some labels or out of bound values
                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

FeatureEngineeringConfiguration = <class 'ML.FeatureEngineeringConfiguration.FeatureEngineeringConfiguration'>
InputsColumnsImportance = <class 'ML.InputsColumnsImportance.InputsColumnsImportance'>
_c_full_df_pre_encoded = None
_c_full_df_user = None
allow_re_run_configuration = True
db_machine = <Machine: <machine:904:__TEST_UNIT__iris_flowers>>
self       = <ML.NNEngine.NNEngine object at 0x00000294084EFE10>
update_data_infos_stats = False

ML\NNEngine.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <machine:904:__TEST_UNIT__iris_flowers>, sort_by = ''
rows_count_limit = None, kwargs = {}

    def data_lines_read(
            self,
            sort_by: str = "",
            rows_count_limit: Optional[int ] = None,
            **kwargs,
    ) -> pd.DataFrame:
        """
        this method get the pandas dataframe which return inner join of two dataframe, one from data_input_lines_read
        and second from data_output_lines_read
    
        :params **kwargs: can be None or column_mode or status for lines
        :return: inner joined pandas dataframe
        """
>       return self.db_machine.read_data_lines_from_db(
            sort_by=sort_by,
            rows_count_limit=rows_count_limit,
            where_clause_dict=kwargs
        )

kwargs     = {}
rows_count_limit = None
self       = <machine:904:__TEST_UNIT__iris_flowers>
sort_by    = ''

ML\Machine.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Machine: <machine:904:__TEST_UNIT__iris_flowers>>, input_columns = None
output_columns = None, where_clause_dict = {}, sort_by = ''
rows_count_limit = None, is_random = False

    def read_data_lines_from_db(
        self,
        input_columns: list = None,
        output_columns: list = None,
        where_clause_dict: dict = None,
        sort_by: str = None,
        rows_count_limit: int = None,
        is_random: bool = False,
    ) -> pd.DataFrame:
    
        _where_clause_dict = {}
        if where_clause_dict:
            where_clause_dict_clean = {
                column_name: column_value
                for column_name, column_value in where_clause_dict.items()
                if column_name not in ("with_reserved_columns", "offset", "")
            }
            _where_clause_dict.update({column_name: "=1" for column_name, column_value in where_clause_dict_clean.items() if column_value is True})
            _where_clause_dict.update({column_name: "=0" for column_name, column_value in where_clause_dict_clean.items() if column_value is False})
    
        _limit_clause = f"LIMIT {rows_count_limit}" if rows_count_limit else ""
    
        if sort_by and is_random:
            logger.error("It is not possible to use simultaneously sort_by and is_random")
        elif sort_by:
            _sort_clause_direction = "DESC" if sort_by.startswith("-") else "ASC"
            _sort_clause = f"ORDER BY `{sort_by}` {_sort_clause_direction}"
        elif is_random:
            _sort_clause = "ORDER BY RAND()"
        else:
            _sort_clause = ""
    
        if isinstance(input_columns, list) and isinstance(output_columns, list) and len(input_columns) != 0 and len(output_columns) != 0:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])}, {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        elif isinstance(input_columns, list) and len(input_columns) != 0 and (output_columns is None or output_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])} FROM Machine_{self.id}_DataInputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and (input_columns is None or input_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} FROM Machine_{self.id}_DataOutputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and not input_columns and _where_clause_dict:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        else:
>           return self.read_data_lines_from_db(
                input_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_input_user_df.items() if column_direction
                ],
                output_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_output_user_df.items() if column_direction
                ],
                where_clause_dict=where_clause_dict,
                sort_by=sort_by,
                rows_count_limit=rows_count_limit,
                is_random=is_random,
            )

_limit_clause = ''
_sort_clause = ''
_where_clause_dict = {}
input_columns = None
is_random  = False
output_columns = None
rows_count_limit = None
self       = <Machine: <machine:904:__TEST_UNIT__iris_flowers>>
sort_by    = ''
where_clause_dict = {}

models\machine.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Machine: <machine:904:__TEST_UNIT__iris_flowers>>
input_columns = ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm', 'PetalWidthCm']
output_columns = ['Species'], where_clause_dict = {}, sort_by = ''
rows_count_limit = None, is_random = False

    def read_data_lines_from_db(
        self,
        input_columns: list = None,
        output_columns: list = None,
        where_clause_dict: dict = None,
        sort_by: str = None,
        rows_count_limit: int = None,
        is_random: bool = False,
    ) -> pd.DataFrame:
    
        _where_clause_dict = {}
        if where_clause_dict:
            where_clause_dict_clean = {
                column_name: column_value
                for column_name, column_value in where_clause_dict.items()
                if column_name not in ("with_reserved_columns", "offset", "")
            }
            _where_clause_dict.update({column_name: "=1" for column_name, column_value in where_clause_dict_clean.items() if column_value is True})
            _where_clause_dict.update({column_name: "=0" for column_name, column_value in where_clause_dict_clean.items() if column_value is False})
    
        _limit_clause = f"LIMIT {rows_count_limit}" if rows_count_limit else ""
    
        if sort_by and is_random:
            logger.error("It is not possible to use simultaneously sort_by and is_random")
        elif sort_by:
            _sort_clause_direction = "DESC" if sort_by.startswith("-") else "ASC"
            _sort_clause = f"ORDER BY `{sort_by}` {_sort_clause_direction}"
        elif is_random:
            _sort_clause = "ORDER BY RAND()"
        else:
            _sort_clause = ""
    
        if isinstance(input_columns, list) and isinstance(output_columns, list) and len(input_columns) != 0 and len(output_columns) != 0:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])}, {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        elif isinstance(input_columns, list) and len(input_columns) != 0 and (output_columns is None or output_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])} FROM Machine_{self.id}_DataInputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and (input_columns is None or input_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} FROM Machine_{self.id}_DataOutputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and not input_columns and _where_clause_dict:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        else:
            return self.read_data_lines_from_db(
                input_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_input_user_df.items() if column_direction
                ],
                output_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_output_user_df.items() if column_direction
                ],
                where_clause_dict=where_clause_dict,
                sort_by=sort_by,
                rows_count_limit=rows_count_limit,
                is_random=is_random,
            )
    
>       _df = pd.read_sql_query(_sql_query, connections["default"])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_limit_clause = ''
_sort_clause = ''
_sql_query = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')
_where_clause = ''
_where_clause_dict = {}
input_columns = ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm', 'PetalWidthCm']
is_random  = False
output_columns = ['Species']
rows_count_limit = None
self       = <Machine: <machine:904:__TEST_UNIT__iris_flowers>>
sort_by    = ''
where_clause_dict = {}

models\machine.py:782: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
con = <DatabaseWrapper vendor='sqlite' alias='default'>, index_col = None
coerce_float = True, params = None, parse_dates = None, chunksize = None
dtype = None, dtype_backend = 'numpy'

    def read_sql_query(
        sql,
        con,
        index_col: str | list[str] | None = None,
        coerce_float: bool = True,
        params: list[Any] | Mapping[str, Any] | None = None,
        parse_dates: list[str] | dict[str, str] | None = None,
        chunksize: int | None = None,
        dtype: DtypeArg | None = None,
        dtype_backend: DtypeBackend | lib.NoDefault = lib.no_default,
    ) -> DataFrame | Iterator[DataFrame]:
        """
        Read SQL query into a DataFrame.
    
        Returns a DataFrame corresponding to the result set of the query
        string. Optionally provide an `index_col` parameter to use one of the
        columns as the index, otherwise default integer index will be used.
    
        Parameters
        ----------
        sql : str SQL query or SQLAlchemy Selectable (select or text object)
            SQL query to be executed.
        con : SQLAlchemy connectable, str, or sqlite3 connection
            Using SQLAlchemy makes it possible to use any DB supported by that
            library. If a DBAPI2 object, only sqlite3 is supported.
        index_col : str or list of str, optional, default: None
            Column(s) to set as index(MultiIndex).
        coerce_float : bool, default True
            Attempts to convert values of non-string, non-numeric objects (like
            decimal.Decimal) to floating point. Useful for SQL result sets.
        params : list, tuple or mapping, optional, default: None
            List of parameters to pass to execute method.  The syntax used
            to pass parameters is database driver dependent. Check your
            database driver documentation for which of the five syntax styles,
            described in PEP 249's paramstyle, is supported.
            Eg. for psycopg2, uses %(name)s so use params={'name' : 'value'}.
        parse_dates : list or dict, default: None
            - List of column names to parse as dates.
            - Dict of ``{column_name: format string}`` where format string is
              strftime compatible in case of parsing string times, or is one of
              (D, s, ns, ms, us) in case of parsing integer timestamps.
            - Dict of ``{column_name: arg dict}``, where the arg dict corresponds
              to the keyword arguments of :func:`pandas.to_datetime`
              Especially useful with databases without native Datetime support,
              such as SQLite.
        chunksize : int, default None
            If specified, return an iterator where `chunksize` is the number of
            rows to include in each chunk.
        dtype : Type name or dict of columns
            Data type for data or columns. E.g. np.float64 or
            {'a': np.float64, 'b': np.int32, 'c': 'Int64'}.
    
            .. versionadded:: 1.3.0
        dtype_backend : {'numpy_nullable', 'pyarrow'}, default 'numpy_nullable'
            Back-end data type applied to the resultant :class:`DataFrame`
            (still experimental). Behaviour is as follows:
    
            * ``"numpy_nullable"``: returns nullable-dtype-backed :class:`DataFrame`
              (default).
            * ``"pyarrow"``: returns pyarrow-backed nullable :class:`ArrowDtype`
              DataFrame.
    
            .. versionadded:: 2.0
    
        Returns
        -------
        DataFrame or Iterator[DataFrame]
    
        See Also
        --------
        read_sql_table : Read SQL database table into a DataFrame.
        read_sql : Read SQL query or database table into a DataFrame.
    
        Notes
        -----
        Any datetime values with time zone information parsed via the `parse_dates`
        parameter will be converted to UTC.
    
        Examples
        --------
        >>> from sqlalchemy import create_engine  # doctest: +SKIP
        >>> engine = create_engine("sqlite:///database.db")  # doctest: +SKIP
        >>> with engine.connect() as conn, conn.begin():  # doctest: +SKIP
        ...     data = pd.read_sql_table("data", conn)  # doctest: +SKIP
        """
    
        check_dtype_backend(dtype_backend)
        if dtype_backend is lib.no_default:
            dtype_backend = "numpy"  # type: ignore[assignment]
        assert dtype_backend is not lib.no_default
    
        with pandasSQL_builder(con) as pandas_sql:
>           return pandas_sql.read_query(
                sql,
                index_col=index_col,
                params=params,
                coerce_float=coerce_float,
                parse_dates=parse_dates,
                chunksize=chunksize,
                dtype=dtype,
                dtype_backend=dtype_backend,
            )

chunksize  = None
coerce_float = True
con        = <DatabaseWrapper vendor='sqlite' alias='default'>
dtype      = None
dtype_backend = 'numpy'
index_col  = None
pandas_sql = <pandas.io.sql.SQLiteDatabase object at 0x000002951384AF10>
params     = None
parse_dates = None
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pandas.io.sql.SQLiteDatabase object at 0x000002951384AF10>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
index_col = None, coerce_float = True, parse_dates = None, params = None
chunksize = None, dtype = None, dtype_backend = 'numpy'

    def read_query(
        self,
        sql,
        index_col=None,
        coerce_float: bool = True,
        parse_dates=None,
        params=None,
        chunksize: int | None = None,
        dtype: DtypeArg | None = None,
        dtype_backend: DtypeBackend | Literal["numpy"] = "numpy",
    ) -> DataFrame | Iterator[DataFrame]:
>       cursor = self.execute(sql, params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

chunksize  = None
coerce_float = True
dtype      = None
dtype_backend = 'numpy'
index_col  = None
params     = None
parse_dates = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x000002951384AF10>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pandas.io.sql.SQLiteDatabase object at 0x000002951384AF10>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql: str | Select | TextClause, params=None):
        if not isinstance(sql, str):
            raise TypeError("Query must be a string unless using sqlalchemy.")
        args = [] if params is None else [params]
        cur = self.con.cursor()
        try:
            cur.execute(sql, *args)
            return cur
        except Exception as exc:
            try:
                self.con.rollback()
            except Exception as inner_exc:  # pragma: no cover
                ex = DatabaseError(
                    f"Execution failed on sql: {sql}\n{exc}\nunable to rollback"
                )
>               raise ex from inner_exc
E               pandas.errors.DatabaseError: Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;
E               no such column: SepalLengthCm
E               unable to rollback

args       = []
cur        = <django.db.backends.utils.CursorWrapper object at 0x000002951384B490>
ex         = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
params     = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x000002951384AF10>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2673: DatabaseError
---------------------------- Captured stderr call -----------------------------
[34mDEBUG   |<frozen runpy>|Creating DFR from C:\Users\Administrator\Documents\Repo-EAML-Core\tests\Tests All AI modules\Test Data - Iris flowers.csv[0m
[34mDEBUG   |<frozen runpy>|Analysing column : SepalLengthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : SepalWidthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : PetalLengthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : PetalWidthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : Species -> DatasetColumnDataType.LABEL[0m
[34mDEBUG   |<frozen runpy>|Reformat DF : 150 rows X 5 cols [0m
[34mDEBUG   |<frozen runpy>|Creation __TEST_UNIT__iris_flowers by DFR [0m
[34mDEBUG   |<frozen runpy>|Creation MachineDataConfiguration from user dataset[0m
[34mDEBUG   |<frozen runpy>|MDC saving configuration full[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine: Empty machine> on disk[0m
[34mDEBUG   |<frozen runpy>|Create_data_tables for <machine:904:__TEST_UNIT__iris_flowers> started[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataInputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataInputLines" (
	"Line_ID" BIGINT, 
	"SepalLengthCm" FLOAT, 
	"SepalWidthCm" FLOAT, 
	"PetalLengthCm" FLOAT, 
	"PetalWidthCm" FLOAT, 
	"IsForLearning" BOOLEAN, 
	"IsForSolving" BOOLEAN, 
	"IsForEvaluation" BOOLEAN, 
	"IsLearned" BOOLEAN, 
	"IsSolved" BOOLEAN
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data input lines was appended. First_new_row_id:1 with arguments:{}[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataOutputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataOutputLines" (
	"Line_ID" BIGINT, 
	"Species" TEXT
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data output lines was appended[0m
[34mDEBUG   |<frozen runpy>|data_lines_appended      SepalLengthCm  SepalWidthCm  PetalLengthCm  PetalWidthCm         Species
0              5.1           3.5            1.4           0.2     Iris-setosa
1              4.9           3.0            1.4           0.2     Iris-setosa
2              4.7           3.2            1.3           0.2     Iris-setosa
3              4.6           3.1            1.5           0.2     Iris-setosa
4              5.0           3.6            1.4           0.2     Iris-setosa
..             ...           ...            ...           ...             ...
145            6.7           3.0            5.2           2.3  Iris-virginica
146            6.3           2.5            5.0           1.9  Iris-virginica
147            6.5           3.0            5.2           2.0  Iris-virginica
148            6.2           3.4            5.4           2.3  Iris-virginica
149            5.9           3.0            5.1           1.8  Iris-virginica

[150 rows x 5 columns] rows, with kwarg:{'machine_description': 'Test machine for Iris flowers dataset'} [0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_UNIT__iris_flowers> on disk[0m
[34mDEBUG   |<frozen runpy>|Machine created and saved : <machine:904:__TEST_UNIT__iris_flowers>[0m
[34mDEBUG   |<frozen runpy>|Saving <machine:904:__TEST_UNIT__iris_flowers> on disk[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_UNIT__iris_flowers> on disk[0m
[34mDEBUG   |<frozen runpy>|NNEngine initializing (loading and/or creating) all configuration for <machine:904:__TEST_UNIT__iris_flowers>[0m
[34mDEBUG   |<frozen runpy>|NNEngine Starting preparing all configurations. [0m
[34mDEBUG   |<frozen runpy>|Loading MachineDataConfiguration for <machine:904:__TEST_UNIT__iris_flowers> starting[0m
[34mDEBUG   |<frozen runpy>|unable to do ICI best configuration because fe or encdec or nnconfig are not ready => doing minimum ICI[0m
[34mDEBUG   |<frozen runpy>|_generate_configuration_default_minimum for <machine:904:__TEST_UNIT__iris_flowers> done[0m
[34mDEBUG   |<frozen runpy>|Updated column importance for machine_source <machine:904:__TEST_UNIT__iris_flowers>[0m
[34mDEBUG   |<frozen runpy>|generate the configuration FE MINIMUM because we cannot do FE_BEST now[0m
[34mDEBUG   |<frozen runpy>|Creation FEC Minimum for <machine:904:__TEST_UNIT__iris_flowers> starting...[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalLengthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalLengthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalWidthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalWidthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalLengthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalLengthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalWidthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalWidthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'Species' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'Species' FEC to (['FETNumericStandardLabel'])[0m
[32mINFO    |<frozen runpy>|Done FEC with force_configuration_simple_minimum=True[0m
[34mDEBUG   |<frozen runpy>|Saving FeatureEngineeringConfiguration in <machine:904:__TEST_UNIT__iris_flowers> [0m
____ TestSalariesPrediction.test_salaries_prediction_diagnostic_row_count _____

self = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
>               return self.cursor.execute(sql)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

ignored_wrapper_args = (False,
 {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
  'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>})
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029495E308C0>
query = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, query, params=None):
        if params is None:
>           return super().execute(query)
                   ^^^^^^^^^^^^^^^^^^^^^^
E           sqlite3.OperationalError: no such column: SepalLengthCm

__class__  = <class 'django.db.backends.sqlite3.base.SQLiteCursorWrapper'>
params     = None
query      = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')
self       = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029495E308C0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\sqlite3\base.py:356: OperationalError

The above exception was the direct cause of the following exception:

self = <pandas.io.sql.SQLiteDatabase object at 0x0000029520D52C50>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql: str | Select | TextClause, params=None):
        if not isinstance(sql, str):
            raise TypeError("Query must be a string unless using sqlalchemy.")
        args = [] if params is None else [params]
        cur = self.con.cursor()
        try:
>           cur.execute(sql, *args)

args       = []
cur        = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
ex         = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
params     = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x0000029520D52C50>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2664: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql, params=None):
>       return self._execute_with_wrappers(
            sql, params, many=False, executor=self._execute
        )

params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None, many = False
executor = <bound method CursorWrapper._execute of <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>>

    def _execute_with_wrappers(self, sql, params, many, executor):
        context = {"connection": self.db, "cursor": self}
        for wrapper in reversed(self.db.execute_wrappers):
            executor = functools.partial(wrapper, executor)
>       return executor(sql, params, many, context)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

context    = {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
 'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>}
executor   = <bound method CursorWrapper._execute of <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>>
many       = False
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
>       with self.db.wrap_database_errors:

ignored_wrapper_args = (False,
 {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
  'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>})
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.utils.DatabaseErrorWrapper object at 0x0000029492DCD2D0>
exc_type = <class 'sqlite3.OperationalError'>
exc_value = OperationalError('no such column: SepalLengthCm')
traceback = <traceback object at 0x000002950D9A9580>

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is None:
            return
        for dj_exc_type in (
            DataError,
            OperationalError,
            IntegrityError,
            InternalError,
            ProgrammingError,
            NotSupportedError,
            DatabaseError,
            InterfaceError,
            Error,
        ):
            db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__)
            if issubclass(exc_type, db_exc_type):
                dj_exc_value = dj_exc_type(*exc_value.args)
                # Only set the 'errors_occurred' flag for errors that may make
                # the connection unusable.
                if dj_exc_type not in (DataError, IntegrityError):
                    self.wrapper.errors_occurred = True
>               raise dj_exc_value.with_traceback(traceback) from exc_value

db_exc_type = <class 'sqlite3.OperationalError'>
dj_exc_type = <class 'django.db.utils.OperationalError'>
dj_exc_value = OperationalError('no such column: SepalLengthCm')
exc_type   = <class 'sqlite3.OperationalError'>
exc_value  = OperationalError('no such column: SepalLengthCm')
self       = <django.db.utils.DatabaseErrorWrapper object at 0x0000029492DCD2D0>
traceback  = <traceback object at 0x000002950D9A9580>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\utils.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
>               return self.cursor.execute(sql)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

ignored_wrapper_args = (False,
 {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
  'cursor': <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>})
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029495E308C0>
query = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, query, params=None):
        if params is None:
>           return super().execute(query)
                   ^^^^^^^^^^^^^^^^^^^^^^
E           django.db.utils.OperationalError: no such column: SepalLengthCm

__class__  = <class 'django.db.backends.sqlite3.base.SQLiteCursorWrapper'>
params     = None
query      = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')
self       = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029495E308C0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\sqlite3\base.py:356: OperationalError

During handling of the above exception, another exception occurred:

self = <pandas.io.sql.SQLiteDatabase object at 0x0000029520D52C50>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql: str | Select | TextClause, params=None):
        if not isinstance(sql, str):
            raise TypeError("Query must be a string unless using sqlalchemy.")
        args = [] if params is None else [params]
        cur = self.con.cursor()
        try:
            cur.execute(sql, *args)
            return cur
        except Exception as exc:
            try:
>               self.con.rollback()

args       = []
cur        = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
ex         = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
params     = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x0000029520D52C50>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = (<DatabaseWrapper vendor='sqlite' alias='default'>,), kwargs = {}

    @wraps(func)
    def inner(*args, **kwargs):
        # Detect a running event loop in this thread.
        try:
            get_running_loop()
        except RuntimeError:
            pass
        else:
            if not os.environ.get("DJANGO_ALLOW_ASYNC_UNSAFE"):
                raise SynchronousOnlyOperation(message)
        # Pass onward.
>       return func(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^

args       = (<DatabaseWrapper vendor='sqlite' alias='default'>,)
func       = <function BaseDatabaseWrapper.rollback at 0x000002943E4C9260>
kwargs     = {}
message    = 'You cannot call this from an async context - use a thread or sync_to_async.'

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\utils\asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DatabaseWrapper vendor='sqlite' alias='default'>

    @async_unsafe
    def rollback(self):
        """Roll back a transaction and reset the dirty flag."""
        self.validate_thread_sharing()
>       self.validate_no_atomic_block()

self       = <DatabaseWrapper vendor='sqlite' alias='default'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\base\base.py:336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DatabaseWrapper vendor='sqlite' alias='default'>

    def validate_no_atomic_block(self):
        """Raise an error if an atomic block is active."""
        if self.in_atomic_block:
>           raise TransactionManagementError(
                "This is forbidden when an 'atomic' block is active."
            )
E           django.db.transaction.TransactionManagementError: This is forbidden when an 'atomic' block is active.

self       = <DatabaseWrapper vendor='sqlite' alias='default'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\base\base.py:515: TransactionManagementError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029409671B20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

cls        = <class '_pytest.runner.CallInfo'>
duration   = Duration(start=Instant(time=1763794614.7020707, perf_count=186831.2714392),
         stop=Instant(time=1763794746.167918, perf_count=186962.7377857))
excinfo    = <ExceptionInfo DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Spec...4_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback') tblen=32>
func       = <function call_and_report.<locals>.<lambda> at 0x0000029409671B20>
instant    = Instant(time=1763794614.7020707, perf_count=186831.2714392)
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
when       = 'call'

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )

item       = <Function test_salaries_prediction_diagnostic_row_count>
kwds       = {}
runtest_hook = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
kwargs     = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
self       = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
hook_name  = 'pytest_runtest_call'
kwargs     = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
methods    = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_diagnostic_row_count>]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6E30>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6E30>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>,
 <generator object CaptureManager.pytest_runtest_call at 0x00000294944FE890>,
 <generator object run_old_style_hookwrapper at 0x000002949490C5E0>,
 <generator object pytest_runtest_call at 0x0000029495EF6E30>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_diagnostic_row_count>]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6E30>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6E30>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>,
 <generator object CaptureManager.pytest_runtest_call at 0x00000294944FE890>,
 <generator object run_old_style_hookwrapper at 0x000002949490C5E0>,
 <generator object pytest_runtest_call at 0x0000029495EF6E30>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>
item = <Function test_salaries_prediction_diagnostic_row_count>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")
    
        with self._runtest_for(item, "call"):
>           yield

item       = <Function test_salaries_prediction_diagnostic_row_count>
self       = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\logging.py:850: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_diagnostic_row_count>]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6E30>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6E30>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>,
 <generator object CaptureManager.pytest_runtest_call at 0x00000294944FE890>,
 <generator object run_old_style_hookwrapper at 0x000002949490C5E0>,
 <generator object pytest_runtest_call at 0x0000029495EF6E30>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io...._io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_salaries_prediction_diagnostic_row_count>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

item       = <Function test_salaries_prediction_diagnostic_row_count>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\capture.py:900: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_diagnostic_row_count>]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6E30>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6E30>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>,
 <generator object CaptureManager.pytest_runtest_call at 0x00000294944FE890>,
 <generator object run_old_style_hookwrapper at 0x000002949490C5E0>,
 <generator object pytest_runtest_call at 0x0000029495EF6E30>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_salaries_prediction_diagnostic_row_count>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

args       = [<Function test_salaries_prediction_diagnostic_row_count>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x000002950D9A8400>
teardown   = <generator object pytest_runtest_call at 0x000002949490AF40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x000002950D9A8400>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

__tracebackhide__ = True
exc        = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
self       = <pluggy._result.Result object at 0x000002950D9A8400>
tb         = <traceback object at 0x000002950D9A8280>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_result.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_salaries_prediction_diagnostic_row_count>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

args       = [<Function test_salaries_prediction_diagnostic_row_count>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x000002950D9A8400>
teardown   = <generator object pytest_runtest_call at 0x000002949490AF40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_diagnostic_row_count>]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6E30>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6E30>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>,
 <generator object CaptureManager.pytest_runtest_call at 0x00000294944FE890>,
 <generator object run_old_style_hookwrapper at 0x000002949490C5E0>,
 <generator object pytest_runtest_call at 0x0000029495EF6E30>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_salaries_prediction_diagnostic_row_count>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)
    
        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)
    
        try:
>           return (yield)
                    ^^^^^

item       = <Function test_salaries_prediction_diagnostic_row_count>
xfailed    = None

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\skipping.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_diagnostic_row_count>]
caller_kwargs = {'item': <Function test_salaries_prediction_diagnostic_row_count>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6E30>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6E30>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x00000294944FEA70>,
 <generator object CaptureManager.pytest_runtest_call at 0x00000294944FE890>,
 <generator object run_old_style_hookwrapper at 0x000002949490C5E0>,
 <generator object pytest_runtest_call at 0x0000029495EF6E30>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_salaries_prediction_diagnostic_row_count>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

item       = <Function test_salaries_prediction_diagnostic_row_count>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_salaries_prediction_diagnostic_row_count>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

self       = <Function test_salaries_prediction_diagnostic_row_count>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:1671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
kwargs     = {'pyfuncitem': <Function test_salaries_prediction_diagnostic_row_count>}
self       = <HookCaller 'pytest_pyfunc_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
kwargs = {'pyfuncitem': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
hook_name  = 'pytest_pyfunc_call'
kwargs     = {'pyfuncitem': <Function test_salaries_prediction_diagnostic_row_count>}
methods    = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_diagnostic_row_count>]
caller_kwargs = {'pyfuncitem': <Function test_salaries_prediction_diagnostic_row_count>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_salaries_prediction_diagnostic_row_count>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_salaries_prediction_diagnostic_row_count>]
caller_kwargs = {'pyfuncitem': <Function test_salaries_prediction_diagnostic_row_count>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_salaries_prediction_diagnostic_row_count>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

funcargs   = {'_dj_autoclear_mailbox': None,
 '_django_clear_site_cache': None,
 '_django_db_marker': None,
 '_django_set_urlconf': None,
 '_django_setup_unittest': None,
 '_fail_for_invalid_template_variable': None,
 '_live_server_helper': None,
 '_template_string_if_invalid_marker': None,
 'db_cleanup': None,
 'django_db_blocker': <pytest_django.plugin.DjangoDbBlocker object at 0x000002940D867690>,
 'django_test_environment': None,
 'monkeypatch': <_pytest.monkeypatch.MonkeyPatch object at 0x0000029501C95110>,
 'request': <FixtureRequest for <Function test_salaries_prediction_diagnostic_row_count>>,
 'session_test_database': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3',
 'test_database': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3',
 'test_database_source': 'C:\\Users\\Administrator\\Documents\\Repo-EAML-Core\\start_set_databases.sqlite3',
 'test_database_with_verification': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'}
pyfuncitem = <Function test_salaries_prediction_diagnostic_row_count>
testargs   = {'test_database_with_verification': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'}
testfunction = <bound method TestSalariesPrediction.test_salaries_prediction_diagnostic_row_count of <unit.test_salaries_prediction.TestSalariesPrediction object at 0x000002949489CCD0>>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unit.test_salaries_prediction.TestSalariesPrediction object at 0x000002949489CCD0>
test_database_with_verification = 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'

    @pytest.mark.django_db
    def test_salaries_prediction_diagnostic_row_count(self, test_database_with_verification):
        """
        DIAGNOSTIC TEST: Investigate why we get 1 row instead of 2
    
        This test provides detailed diagnostics about:
        - CSV file structure and row count
        - Row selection process
        - Encoding process (pre-encode, encode_for_ai)
        - Solving process
        - Where rows might be lost
        """
        # Get CSV file path
        test_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        csv_file_path = os.path.join(
            test_dir,
            "Test Data - Iris flowers.csv"
        )
    
        assert os.path.exists(csv_file_path), f"CSV file not found at {csv_file_path}"
    
        # Read CSV
        df_full = pd.read_csv(csv_file_path)
    
        print(f"\n{'='*80}")
        print(f"DIAGNOSTIC TEST: Row Count Investigation (Iris Dataset)")
        print(f"{'='*80}")
        print(f"\n1. CSV FILE ANALYSIS")
        print(f"   File: {csv_file_path}")
        print(f"   Total rows (DataFrame): {len(df_full)}")
        print(f"   Total rows (including header): {len(df_full) + 1}")
        print(f"   Columns: {list(df_full.columns)}")
        print(f"   Shape: {df_full.shape}")
    
        # Use rows 75-76 from Iris dataset
        target_indices = [75, 76]
        print(f"\n2. TARGET ROWS ANALYSIS")
        print(f"   Requested indices: {target_indices}")
        print(f"   Available indices: 0 to {len(df_full) - 1}")
    
        # Select rows
        solving_rows = df_full.iloc[target_indices[0]:target_indices[-1]+1]
        print(f"\n3. SELECTED ROWS")
        print(f"   Selected indices: {list(solving_rows.index)}")
        print(f"   Number of rows: {len(solving_rows)}")
        print(f"   Rows data:")
        print(solving_rows.to_string())
    
        # Check for NaN values
        print(f"\n4. DATA QUALITY CHECK")
        nan_count = solving_rows.isna().sum().sum()
        print(f"   Total NaN values: {nan_count}")
        if nan_count > 0:
            print(f"   NaN by column:")
            for col in solving_rows.columns:
                nan_col = solving_rows[col].isna().sum()
                if nan_col > 0:
                    print(f"     - {col}: {nan_col} NaN values")
                    print(f"       Rows with NaN: {list(solving_rows[solving_rows[col].isna()].index)}")
    
        # Check output column
        output_column = "Species"
        print(f"\n5. OUTPUT COLUMN CHECK")
        if output_column in solving_rows.columns:
            print(f"    Output column '{output_column}' found")
            solving_dataframe = solving_rows.drop(columns=[output_column])
        else:
            print(f"     Output column '{output_column}' NOT found")
            print(f"   Available columns: {list(solving_rows.columns)}")
            species_cols = [col for col in solving_rows.columns if 'species' in col.lower()]
            if species_cols:
                output_column = species_cols[0]
                print(f"   Using '{output_column}' instead")
                solving_dataframe = solving_rows.drop(columns=[output_column])
            else:
                solving_dataframe = solving_rows.copy()
    
        print(f"\n6. SOLVING DATAFRAME (INPUTS ONLY)")
        print(f"   Rows: {len(solving_dataframe)}")
        print(f"   Columns: {list(solving_dataframe.columns)}")
        print(f"   Shape: {solving_dataframe.shape}")
        print(f"   Index: {list(solving_dataframe.index)}")
        print(f"   Data:")
        print(solving_dataframe.to_string())
    
        # Create machine (minimal setup for diagnostics)
        try:
            from conftest import get_admin_user
            dfr = DataFileReader(csv_file_path, date_format="MDY", decimal_separator=".")
            formatted_df = dfr.get_formatted_user_dataframe
            columns_description = dfr.get_user_columns_description or {}
            for col in formatted_df.columns:
                if col not in columns_description:
                    columns_description[col] = f"Column {col}"
    
            machine = Machine(
                "__TEST_UNIT__iris_diagnostic",
                dfr=dfr,
                decimal_separator=".",
                date_format="MDY",
                machine_create_user_id=get_admin_user().id,
                machine_create_team_id=1,
                force_create_with_this_descriptions=columns_description,
                machine_level=1,
                disable_foreign_key_checking=True
            )
            machine.save_machine_to_db()
    
            # Create NNEngine and train
>           nn_engine = NNEngine(machine, allow_re_run_configuration=True)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

col        = 'Species'
columns_description = {'PetalLengthCm': 'input',
 'PetalWidthCm': 'input',
 'SepalLengthCm': 'input',
 'SepalWidthCm': 'input',
 'Species': 'output'}
csv_file_path = ('C:\\Users\\Administrator\\Documents\\Repo-EAML-Core\\tests\\Tests All AI '
 'modules\\Test Data - Iris flowers.csv')
df_full    =     SepalLengthCm SepalWidthCm PetalLengthCm PetalWidthCm         Species
0           input        input         input        input          output
1             5.1          3.5           1.4          0.2     Iris-setosa
2             4.9          3.0           1.4          0.2     Iris-setosa
3             4.7          3.2           1.3          0.2     Iris-setosa
4             4.6          3.1           1.5          0.2     Iris-setosa
..            ...          ...           ...          ...             ...
146           6.7          3.0           5.2          2.3  Iris-virginica
147           6.3          2.5           5.0          1.9  Iris-virginica
148           6.5          3.0           5.2          2.0  Iris-virginica
149           6.2          3.4           5.4          2.3  Iris-virginica
150           5.9          3.0           5.1          1.8  Iris-virginica

[151 rows x 5 columns]
dfr        = <ML.DataFileReader.DataFileReader object at 0x0000029501C97B10>
formatted_df =      SepalLengthCm  SepalWidthCm  PetalLengthCm  PetalWidthCm         Species
0              5.1           3.5            1.4           0.2     Iris-setosa
1              4.9           3.0            1.4           0.2     Iris-setosa
2              4.7           3.2            1.3           0.2     Iris-setosa
3              4.6           3.1            1.5           0.2     Iris-setosa
4              5.0           3.6            1.4           0.2     Iris-setosa
..             ...           ...            ...           ...             ...
145            6.7           3.0            5.2           2.3  Iris-virginica
146            6.3           2.5            5.0           1.9  Iris-virginica
147            6.5           3.0            5.2           2.0  Iris-virginica
148            6.2           3.4            5.4           2.3  Iris-virginica
149            5.9           3.0            5.1           1.8  Iris-virginica

[150 rows x 5 columns]
get_admin_user = <function get_admin_user at 0x000002943E92EF20>
machine    = <machine:904:__TEST_UNIT__iris_diagnostic...>
nan_count  = 0
output_column = 'Species'
self       = <unit.test_salaries_prediction.TestSalariesPrediction object at 0x000002949489CCD0>
solving_dataframe =    SepalLengthCm SepalWidthCm PetalLengthCm PetalWidthCm
75           6.4          2.9           4.3          1.3
76           6.6          3.0           4.4          1.4
solving_rows =    SepalLengthCm SepalWidthCm PetalLengthCm PetalWidthCm          Species
75           6.4          2.9           4.3          1.3  Iris-versicolor
76           6.6          3.0           4.4          1.4  Iris-versicolor
target_indices = [75, 76]
test_database_with_verification = 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'
test_dir   = ('C:\\Users\\Administrator\\Documents\\Repo-EAML-Core\\tests\\Tests All AI '
 'modules')
traceback  = <module 'traceback' from 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\traceback.py'>

tests\Tests All AI modules\unit\test_salaries_prediction.py:390: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ML.NNEngine.NNEngine object at 0x00000294084EFB90>
machine = <machine:904:__TEST_UNIT__iris_diagnostic...>
allow_re_run_configuration = True

    def __init__( self, machine: Machine, allow_re_run_configuration: bool = False ):
        """
        Create NNEngine or load it from Machine
        If configuration are available inside Machine we use it else we will generate it
    
        :param machine: the machine to work on
        """
        if not isinstance(machine, Machine):
            logger.error( "The constructor argument must have an instance of the machine" )
    
        self._machine = machine
        self._mdc = None
        self._ici = None
        self._fe = None
        self._enc_dec = None
        self._nn_configuration = None
        self._nn_model = None
    
        if IS_RUNNING_IN_DEBUG_MODE:
>           self._init_load_or_create_configuration( allow_re_run_configuration=allow_re_run_configuration )

allow_re_run_configuration = True
machine    = <machine:904:__TEST_UNIT__iris_diagnostic...>
self       = <ML.NNEngine.NNEngine object at 0x00000294084EFB90>

ML\NNEngine.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ML.NNEngine.NNEngine object at 0x00000294084EFB90>
allow_re_run_configuration = True, update_data_infos_stats = False

    def _init_load_or_create_configuration( self , allow_re_run_configuration: bool = False , update_data_infos_stats:bool=False ):
        """
        Create NNEngine or load it from Machine
        If configuration are available inside Machine we use it else we will generate it
    
        All configurations to run NNEngine will be prepared here
        NNEngine need to have all this configurations built : MDC, CI, FE, EncDec, NNConfiguration, NNModel
        We try to use the configuration stored into machine, if not available we will generate the configuration, using best if possible or else doing minimum_default
    
        at each step we load the configuration or we create the configuration and save it into machine object
        only last step : training nn model is not performed here (sometime we need nnengine for performing trial learning)
    
        Some flag can trigger some configuration to be rebuilt : re_run - If one Config need to be rebuilt then all following Config will be cleared and rebuilt
        """
    
        if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"NNEngine initializing (loading and/or creating) all configuration for {self._machine}" )
    
        db_machine = self._machine.db_machine
    
        # MDC and EncDec may load and use the dataset - we cache it for faster
        _c_full_df_user = None
        _c_full_df_pre_encoded = None
    
        if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"NNEngine Starting preparing all configurations. " )
        self.machine_nn_engine_configuration_set_starting( self._machine )
    
        # -----------------------------------------
        #  MDC
        # -----------------------------------------
        if not self._machine.is_config_ready_mdc() or (allow_re_run_configuration and db_machine.machine_is_re_run_mdc):
            _c_full_df_user = self._machine.data_lines_read( ) # we have to use the full dataset because with a subset we could miss some labels or out of bound values
            # We do not indicate what user choose because anyway the dataset is formatted and this 2 parameters are useless : decimal_separator  date_format
            self._mdc = MachineDataConfiguration(
                                                    self._machine,
                                                    _c_full_df_user,
                                                    force_create_with_this_inputs=self._machine.db_machine.mdc_columns_name_input,    # we cannot change this after creation
                                                    force_create_with_this_outputs=self._machine.db_machine.mdc_columns_name_output, # we cannot change this after creation
                                                    columns_type_user_df=self._machine.db_machine.dfr_columns_type_user_df,
                                                    columns_description_user_df= self._machine.db_machine.dfr_columns_description_user_df,
                                                    decimal_separator = ".",
                                                    date_format = "MDY" )
            self._mdc.save_configuration_in_machine( )
            # rerun configuration have been done, we can clear the flag
            db_machine.machine_is_re_run_mdc = False
    
            # configuration regenerated need to force following configurations to be rebuilt too
            self._machine.clear_config_ici( )
            self._machine.clear_config_fe( )
            self._machine.clear_config_enc_dec( )
            self._machine.clear_config_nn_configuration( )
            self._machine.clear_config_nn_model( )
    
        else:
            self._mdc = MachineDataConfiguration(self._machine)
            if update_data_infos_stats:
                _c_full_df_user = self._machine.data_lines_read( )  # we have to use the full dataset because with a subset we could miss some labels or out of bound values
                _c_full_df_pre_encoded = self._mdc.dataframe_pre_encode( _c_full_df_user )
                self._mdc._recalculate_data_infos_stats( _c_full_df_pre_encoded, decimal_separator = ".", date_format = "MDY" )
    
        # -----------------------------------------
        #  Column Importance
        # -----------------------------------------
        from ML.InputsColumnsImportance import InputsColumnsImportance
        if not self._machine.is_config_ready_ici( ) or (allow_re_run_configuration and db_machine.machine_is_re_run_ici):
            if (
                    not self._machine.is_config_ready_fe() or
                    not self._machine.is_config_ready_enc_dec() or
                    not self._machine.is_config_ready_nn_configuration() or
                    not self.is_nn_trained_and_ready()
                ):
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( "unable to do ICI best configuration because fe or encdec or nnconfig are not ready => doing minimum ICI" )
                self._ici = InputsColumnsImportance( self._machine , create_configuration_simple_minimum=True).save_configuration_in_machine()
                db_machine.machine_is_re_run_ici = True
            else:
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( "do ICI best configuration because fe or encdec or nnconfig are ready" )
                self._ici = InputsColumnsImportance( self._machine , create_configuration_best=True, nnengine_for_best_config=self ).save_configuration_in_machine()
                # rerun configuration have been done, we can clear the flag
                db_machine.machine_is_re_run_ici = False
    
            # configuration regenerated need to force following configurations to be rebuilt too
            self._machine.clear_config_fe( )
            self._machine.clear_config_enc_dec( )
            self._machine.clear_config_nn_configuration( )
            self._machine.clear_config_nn_model( )
    
        else:
            # load the configuration ICI by default if no force flag and if not needed by rerun to make configuration
             self._ici = InputsColumnsImportance( self._machine )
    
        # -----------------------------------------
        #  FE
        # -----------------------------------------
        from ML.FeatureEngineeringConfiguration import FeatureEngineeringConfiguration
        if not self._machine.is_config_ready_fe() or (allow_re_run_configuration and db_machine.machine_is_re_run_fe):
            if (
                    not self._machine.is_config_ready_enc_dec() or
                    not self._machine.is_config_ready_nn_configuration()
                    ):
                # generate the configuration FE MINIMUM because we cannot do FE_BEST now
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"generate the configuration FE MINIMUM because we cannot do FE_BEST now" )
                self._fe = FeatureEngineeringConfiguration(
                    machine=self._machine,
                    force_configuration_simple_minimum=True
                    ).save_configuration_in_machine()
                # we will do best FE later
                db_machine.machine_is_re_run_fe = True
            else:
                # generate the configuration FE BEST
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"generate the configuration FE BEST  " )
                db_machine.fe_budget_total = MachineLevel(self._machine).feature_engineering_budget()[1]
                # load (never do best config of course) the nnconfiguration that we will use to evaluate the FEC
                self._nn_configuration = NNConfiguration(self._machine)
                self._fe = FeatureEngineeringConfiguration(
                    machine=self._machine,
                    nn_engine_for_searching_best_config=self,
                    global_dataset_budget=self._machine.db_machine.fe_budget_total,
                    force_configuration_simple_minimum=False,
                    ).save_configuration_in_machine()
                # rerun configuration have been done, we can clear the flag
                db_machine.machine_is_re_run_fe = False
    
            #  configuration regenerated need to force following configurations to be rebuilt too
            self._machine.clear_config_enc_dec( )
            self._machine.clear_config_nn_configuration( )
            self._machine.clear_config_nn_model( )
    
        else:
            # load the configuration FE
            self._fe = FeatureEngineeringConfiguration(self._machine)
    
    
        # -----------------------------------------
        #  EncDec
        # -----------------------------------------
        if not self._machine.is_config_ready_enc_dec( ) or (allow_re_run_configuration and db_machine.machine_is_re_run_enc_dec):
            # generate configuration encdec
            if _c_full_df_pre_encoded is None:
                if _c_full_df_user is None:
>                   _c_full_df_user = self._machine.data_lines_read( ) # we have to use the full dataset because with a subset we could miss some labels or out of bound values
                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

FeatureEngineeringConfiguration = <class 'ML.FeatureEngineeringConfiguration.FeatureEngineeringConfiguration'>
InputsColumnsImportance = <class 'ML.InputsColumnsImportance.InputsColumnsImportance'>
_c_full_df_pre_encoded = None
_c_full_df_user = None
allow_re_run_configuration = True
db_machine = <Machine: <machine:904:__TEST_UNIT__iris_diagnostic...>>
self       = <ML.NNEngine.NNEngine object at 0x00000294084EFB90>
update_data_infos_stats = False

ML\NNEngine.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <machine:904:__TEST_UNIT__iris_diagnostic...>, sort_by = ''
rows_count_limit = None, kwargs = {}

    def data_lines_read(
            self,
            sort_by: str = "",
            rows_count_limit: Optional[int ] = None,
            **kwargs,
    ) -> pd.DataFrame:
        """
        this method get the pandas dataframe which return inner join of two dataframe, one from data_input_lines_read
        and second from data_output_lines_read
    
        :params **kwargs: can be None or column_mode or status for lines
        :return: inner joined pandas dataframe
        """
>       return self.db_machine.read_data_lines_from_db(
            sort_by=sort_by,
            rows_count_limit=rows_count_limit,
            where_clause_dict=kwargs
        )

kwargs     = {}
rows_count_limit = None
self       = <machine:904:__TEST_UNIT__iris_diagnostic...>
sort_by    = ''

ML\Machine.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Machine: <machine:904:__TEST_UNIT__iris_diagnostic...>>
input_columns = None, output_columns = None, where_clause_dict = {}
sort_by = '', rows_count_limit = None, is_random = False

    def read_data_lines_from_db(
        self,
        input_columns: list = None,
        output_columns: list = None,
        where_clause_dict: dict = None,
        sort_by: str = None,
        rows_count_limit: int = None,
        is_random: bool = False,
    ) -> pd.DataFrame:
    
        _where_clause_dict = {}
        if where_clause_dict:
            where_clause_dict_clean = {
                column_name: column_value
                for column_name, column_value in where_clause_dict.items()
                if column_name not in ("with_reserved_columns", "offset", "")
            }
            _where_clause_dict.update({column_name: "=1" for column_name, column_value in where_clause_dict_clean.items() if column_value is True})
            _where_clause_dict.update({column_name: "=0" for column_name, column_value in where_clause_dict_clean.items() if column_value is False})
    
        _limit_clause = f"LIMIT {rows_count_limit}" if rows_count_limit else ""
    
        if sort_by and is_random:
            logger.error("It is not possible to use simultaneously sort_by and is_random")
        elif sort_by:
            _sort_clause_direction = "DESC" if sort_by.startswith("-") else "ASC"
            _sort_clause = f"ORDER BY `{sort_by}` {_sort_clause_direction}"
        elif is_random:
            _sort_clause = "ORDER BY RAND()"
        else:
            _sort_clause = ""
    
        if isinstance(input_columns, list) and isinstance(output_columns, list) and len(input_columns) != 0 and len(output_columns) != 0:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])}, {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        elif isinstance(input_columns, list) and len(input_columns) != 0 and (output_columns is None or output_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])} FROM Machine_{self.id}_DataInputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and (input_columns is None or input_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} FROM Machine_{self.id}_DataOutputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and not input_columns and _where_clause_dict:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        else:
>           return self.read_data_lines_from_db(
                input_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_input_user_df.items() if column_direction
                ],
                output_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_output_user_df.items() if column_direction
                ],
                where_clause_dict=where_clause_dict,
                sort_by=sort_by,
                rows_count_limit=rows_count_limit,
                is_random=is_random,
            )

_limit_clause = ''
_sort_clause = ''
_where_clause_dict = {}
input_columns = None
is_random  = False
output_columns = None
rows_count_limit = None
self       = <Machine: <machine:904:__TEST_UNIT__iris_diagnostic...>>
sort_by    = ''
where_clause_dict = {}

models\machine.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Machine: <machine:904:__TEST_UNIT__iris_diagnostic...>>
input_columns = ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm', 'PetalWidthCm']
output_columns = ['Species'], where_clause_dict = {}, sort_by = ''
rows_count_limit = None, is_random = False

    def read_data_lines_from_db(
        self,
        input_columns: list = None,
        output_columns: list = None,
        where_clause_dict: dict = None,
        sort_by: str = None,
        rows_count_limit: int = None,
        is_random: bool = False,
    ) -> pd.DataFrame:
    
        _where_clause_dict = {}
        if where_clause_dict:
            where_clause_dict_clean = {
                column_name: column_value
                for column_name, column_value in where_clause_dict.items()
                if column_name not in ("with_reserved_columns", "offset", "")
            }
            _where_clause_dict.update({column_name: "=1" for column_name, column_value in where_clause_dict_clean.items() if column_value is True})
            _where_clause_dict.update({column_name: "=0" for column_name, column_value in where_clause_dict_clean.items() if column_value is False})
    
        _limit_clause = f"LIMIT {rows_count_limit}" if rows_count_limit else ""
    
        if sort_by and is_random:
            logger.error("It is not possible to use simultaneously sort_by and is_random")
        elif sort_by:
            _sort_clause_direction = "DESC" if sort_by.startswith("-") else "ASC"
            _sort_clause = f"ORDER BY `{sort_by}` {_sort_clause_direction}"
        elif is_random:
            _sort_clause = "ORDER BY RAND()"
        else:
            _sort_clause = ""
    
        if isinstance(input_columns, list) and isinstance(output_columns, list) and len(input_columns) != 0 and len(output_columns) != 0:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])}, {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        elif isinstance(input_columns, list) and len(input_columns) != 0 and (output_columns is None or output_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])} FROM Machine_{self.id}_DataInputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and (input_columns is None or input_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} FROM Machine_{self.id}_DataOutputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and not input_columns and _where_clause_dict:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        else:
            return self.read_data_lines_from_db(
                input_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_input_user_df.items() if column_direction
                ],
                output_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_output_user_df.items() if column_direction
                ],
                where_clause_dict=where_clause_dict,
                sort_by=sort_by,
                rows_count_limit=rows_count_limit,
                is_random=is_random,
            )
    
>       _df = pd.read_sql_query(_sql_query, connections["default"])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_limit_clause = ''
_sort_clause = ''
_sql_query = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')
_where_clause = ''
_where_clause_dict = {}
input_columns = ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm', 'PetalWidthCm']
is_random  = False
output_columns = ['Species']
rows_count_limit = None
self       = <Machine: <machine:904:__TEST_UNIT__iris_diagnostic...>>
sort_by    = ''
where_clause_dict = {}

models\machine.py:782: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
con = <DatabaseWrapper vendor='sqlite' alias='default'>, index_col = None
coerce_float = True, params = None, parse_dates = None, chunksize = None
dtype = None, dtype_backend = 'numpy'

    def read_sql_query(
        sql,
        con,
        index_col: str | list[str] | None = None,
        coerce_float: bool = True,
        params: list[Any] | Mapping[str, Any] | None = None,
        parse_dates: list[str] | dict[str, str] | None = None,
        chunksize: int | None = None,
        dtype: DtypeArg | None = None,
        dtype_backend: DtypeBackend | lib.NoDefault = lib.no_default,
    ) -> DataFrame | Iterator[DataFrame]:
        """
        Read SQL query into a DataFrame.
    
        Returns a DataFrame corresponding to the result set of the query
        string. Optionally provide an `index_col` parameter to use one of the
        columns as the index, otherwise default integer index will be used.
    
        Parameters
        ----------
        sql : str SQL query or SQLAlchemy Selectable (select or text object)
            SQL query to be executed.
        con : SQLAlchemy connectable, str, or sqlite3 connection
            Using SQLAlchemy makes it possible to use any DB supported by that
            library. If a DBAPI2 object, only sqlite3 is supported.
        index_col : str or list of str, optional, default: None
            Column(s) to set as index(MultiIndex).
        coerce_float : bool, default True
            Attempts to convert values of non-string, non-numeric objects (like
            decimal.Decimal) to floating point. Useful for SQL result sets.
        params : list, tuple or mapping, optional, default: None
            List of parameters to pass to execute method.  The syntax used
            to pass parameters is database driver dependent. Check your
            database driver documentation for which of the five syntax styles,
            described in PEP 249's paramstyle, is supported.
            Eg. for psycopg2, uses %(name)s so use params={'name' : 'value'}.
        parse_dates : list or dict, default: None
            - List of column names to parse as dates.
            - Dict of ``{column_name: format string}`` where format string is
              strftime compatible in case of parsing string times, or is one of
              (D, s, ns, ms, us) in case of parsing integer timestamps.
            - Dict of ``{column_name: arg dict}``, where the arg dict corresponds
              to the keyword arguments of :func:`pandas.to_datetime`
              Especially useful with databases without native Datetime support,
              such as SQLite.
        chunksize : int, default None
            If specified, return an iterator where `chunksize` is the number of
            rows to include in each chunk.
        dtype : Type name or dict of columns
            Data type for data or columns. E.g. np.float64 or
            {'a': np.float64, 'b': np.int32, 'c': 'Int64'}.
    
            .. versionadded:: 1.3.0
        dtype_backend : {'numpy_nullable', 'pyarrow'}, default 'numpy_nullable'
            Back-end data type applied to the resultant :class:`DataFrame`
            (still experimental). Behaviour is as follows:
    
            * ``"numpy_nullable"``: returns nullable-dtype-backed :class:`DataFrame`
              (default).
            * ``"pyarrow"``: returns pyarrow-backed nullable :class:`ArrowDtype`
              DataFrame.
    
            .. versionadded:: 2.0
    
        Returns
        -------
        DataFrame or Iterator[DataFrame]
    
        See Also
        --------
        read_sql_table : Read SQL database table into a DataFrame.
        read_sql : Read SQL query or database table into a DataFrame.
    
        Notes
        -----
        Any datetime values with time zone information parsed via the `parse_dates`
        parameter will be converted to UTC.
    
        Examples
        --------
        >>> from sqlalchemy import create_engine  # doctest: +SKIP
        >>> engine = create_engine("sqlite:///database.db")  # doctest: +SKIP
        >>> with engine.connect() as conn, conn.begin():  # doctest: +SKIP
        ...     data = pd.read_sql_table("data", conn)  # doctest: +SKIP
        """
    
        check_dtype_backend(dtype_backend)
        if dtype_backend is lib.no_default:
            dtype_backend = "numpy"  # type: ignore[assignment]
        assert dtype_backend is not lib.no_default
    
        with pandasSQL_builder(con) as pandas_sql:
>           return pandas_sql.read_query(
                sql,
                index_col=index_col,
                params=params,
                coerce_float=coerce_float,
                parse_dates=parse_dates,
                chunksize=chunksize,
                dtype=dtype,
                dtype_backend=dtype_backend,
            )

chunksize  = None
coerce_float = True
con        = <DatabaseWrapper vendor='sqlite' alias='default'>
dtype      = None
dtype_backend = 'numpy'
index_col  = None
pandas_sql = <pandas.io.sql.SQLiteDatabase object at 0x0000029520D52C50>
params     = None
parse_dates = None
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pandas.io.sql.SQLiteDatabase object at 0x0000029520D52C50>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
index_col = None, coerce_float = True, parse_dates = None, params = None
chunksize = None, dtype = None, dtype_backend = 'numpy'

    def read_query(
        self,
        sql,
        index_col=None,
        coerce_float: bool = True,
        parse_dates=None,
        params=None,
        chunksize: int | None = None,
        dtype: DtypeArg | None = None,
        dtype_backend: DtypeBackend | Literal["numpy"] = "numpy",
    ) -> DataFrame | Iterator[DataFrame]:
>       cursor = self.execute(sql, params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

chunksize  = None
coerce_float = True
dtype      = None
dtype_backend = 'numpy'
index_col  = None
params     = None
parse_dates = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x0000029520D52C50>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pandas.io.sql.SQLiteDatabase object at 0x0000029520D52C50>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql: str | Select | TextClause, params=None):
        if not isinstance(sql, str):
            raise TypeError("Query must be a string unless using sqlalchemy.")
        args = [] if params is None else [params]
        cur = self.con.cursor()
        try:
            cur.execute(sql, *args)
            return cur
        except Exception as exc:
            try:
                self.con.rollback()
            except Exception as inner_exc:  # pragma: no cover
                ex = DatabaseError(
                    f"Execution failed on sql: {sql}\n{exc}\nunable to rollback"
                )
>               raise ex from inner_exc
E               pandas.errors.DatabaseError: Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;
E               no such column: SepalLengthCm
E               unable to rollback

args       = []
cur        = <django.db.backends.utils.CursorWrapper object at 0x000002951E408390>
ex         = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
params     = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x0000029520D52C50>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2673: DatabaseError
---------------------------- Captured stdout call -----------------------------

================================================================================
DIAGNOSTIC TEST: Row Count Investigation (Iris Dataset)
================================================================================

1. CSV FILE ANALYSIS
   File: C:\Users\Administrator\Documents\Repo-EAML-Core\tests\Tests All AI modules\Test Data - Iris flowers.csv
   Total rows (DataFrame): 151
   Total rows (including header): 152
   Columns: ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm', 'PetalWidthCm', 'Species']
   Shape: (151, 5)

2. TARGET ROWS ANALYSIS
   Requested indices: [75, 76]
   Available indices: 0 to 150

3. SELECTED ROWS
   Selected indices: [75, 76]
   Number of rows: 2
   Rows data:
   SepalLengthCm SepalWidthCm PetalLengthCm PetalWidthCm          Species
75           6.4          2.9           4.3          1.3  Iris-versicolor
76           6.6          3.0           4.4          1.4  Iris-versicolor

4. DATA QUALITY CHECK
   Total NaN values: 0

5. OUTPUT COLUMN CHECK
    Output column 'Species' found

6. SOLVING DATAFRAME (INPUTS ONLY)
   Rows: 2
   Columns: ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm', 'PetalWidthCm']
   Shape: (2, 4)
   Index: [75, 76]
   Data:
   SepalLengthCm SepalWidthCm PetalLengthCm PetalWidthCm
75           6.4          2.9           4.3          1.3
76           6.6          3.0           4.4          1.4

    ERROR during diagnostic: Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;
no such column: SepalLengthCm
unable to rollback
---------------------------- Captured stderr call -----------------------------
[34mDEBUG   |<frozen runpy>|Creating DFR from C:\Users\Administrator\Documents\Repo-EAML-Core\tests\Tests All AI modules\Test Data - Iris flowers.csv[0m
[34mDEBUG   |<frozen runpy>|Analysing column : SepalLengthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : SepalWidthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : PetalLengthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : PetalWidthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : Species -> DatasetColumnDataType.LABEL[0m
[34mDEBUG   |<frozen runpy>|Reformat DF : 150 rows X 5 cols [0m
[34mDEBUG   |<frozen runpy>|Creation __TEST_UNIT__iris_diagnostic by DFR [0m
[34mDEBUG   |<frozen runpy>|Creation MachineDataConfiguration from user dataset[0m
[34mDEBUG   |<frozen runpy>|MDC saving configuration full[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine: Empty machine> on disk[0m
[34mDEBUG   |<frozen runpy>|Create_data_tables for <machine:904:__TEST_UNIT__iris_diagnostic...> started[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataInputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataInputLines" (
	"Line_ID" BIGINT, 
	"SepalLengthCm" FLOAT, 
	"SepalWidthCm" FLOAT, 
	"PetalLengthCm" FLOAT, 
	"PetalWidthCm" FLOAT, 
	"IsForLearning" BOOLEAN, 
	"IsForSolving" BOOLEAN, 
	"IsForEvaluation" BOOLEAN, 
	"IsLearned" BOOLEAN, 
	"IsSolved" BOOLEAN
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data input lines was appended. First_new_row_id:1 with arguments:{}[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataOutputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataOutputLines" (
	"Line_ID" BIGINT, 
	"Species" TEXT
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data output lines was appended[0m
[34mDEBUG   |<frozen runpy>|data_lines_appended      SepalLengthCm  SepalWidthCm  PetalLengthCm  PetalWidthCm         Species
0              5.1           3.5            1.4           0.2     Iris-setosa
1              4.9           3.0            1.4           0.2     Iris-setosa
2              4.7           3.2            1.3           0.2     Iris-setosa
3              4.6           3.1            1.5           0.2     Iris-setosa
4              5.0           3.6            1.4           0.2     Iris-setosa
..             ...           ...            ...           ...             ...
145            6.7           3.0            5.2           2.3  Iris-virginica
146            6.3           2.5            5.0           1.9  Iris-virginica
147            6.5           3.0            5.2           2.0  Iris-virginica
148            6.2           3.4            5.4           2.3  Iris-virginica
149            5.9           3.0            5.1           1.8  Iris-virginica

[150 rows x 5 columns] rows, with kwarg:{} [0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_UNIT__iris_diagnostic...> on disk[0m
[34mDEBUG   |<frozen runpy>|Machine created and saved : <machine:904:__TEST_UNIT__iris_diagnostic...>[0m
[34mDEBUG   |<frozen runpy>|Saving <machine:904:__TEST_UNIT__iris_diagnostic...> on disk[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_UNIT__iris_diagnostic...> on disk[0m
[34mDEBUG   |<frozen runpy>|NNEngine initializing (loading and/or creating) all configuration for <machine:904:__TEST_UNIT__iris_diagnostic...>[0m
[34mDEBUG   |<frozen runpy>|NNEngine Starting preparing all configurations. [0m
[34mDEBUG   |<frozen runpy>|Loading MachineDataConfiguration for <machine:904:__TEST_UNIT__iris_diagnostic...> starting[0m
[34mDEBUG   |<frozen runpy>|unable to do ICI best configuration because fe or encdec or nnconfig are not ready => doing minimum ICI[0m
[34mDEBUG   |<frozen runpy>|_generate_configuration_default_minimum for <machine:904:__TEST_UNIT__iris_diagnostic...> done[0m
[34mDEBUG   |<frozen runpy>|Updated column importance for machine_source <machine:904:__TEST_UNIT__iris_diagnostic...>[0m
[34mDEBUG   |<frozen runpy>|generate the configuration FE MINIMUM because we cannot do FE_BEST now[0m
[34mDEBUG   |<frozen runpy>|Creation FEC Minimum for <machine:904:__TEST_UNIT__iris_diagnostic...> starting...[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalLengthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalLengthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalWidthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalWidthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalLengthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalLengthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalWidthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalWidthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'Species' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'Species' FEC to (['FETNumericStandardLabel'])[0m
[32mINFO    |<frozen runpy>|Done FEC with force_configuration_simple_minimum=True[0m
[34mDEBUG   |<frozen runpy>|Saving FeatureEngineeringConfiguration in <machine:904:__TEST_UNIT__iris_diagnostic...> [0m
Traceback (most recent call last):
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py", line 103, in _execute
    return self.cursor.execute(sql)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\sqlite3\base.py", line 356, in execute
    return super().execute(query)
           ^^^^^^^^^^^^^^^^^^^^^^
sqlite3.OperationalError: no such column: SepalLengthCm

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py", line 79, in execute
    return self._execute_with_wrappers(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py", line 92, in _execute_with_wrappers
    return executor(sql, params, many, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py", line 100, in _execute
    with self.db.wrap_database_errors:
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\utils.py", line 91, in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py", line 103, in _execute
    return self.cursor.execute(sql)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\sqlite3\base.py", line 356, in execute
    return super().execute(query)
           ^^^^^^^^^^^^^^^^^^^^^^
django.db.utils.OperationalError: no such column: SepalLengthCm

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py", line 2668, in execute
    self.con.rollback()
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\utils\asyncio.py", line 26, in inner
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\base\base.py", line 336, in rollback
    self.validate_no_atomic_block()
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\base\base.py", line 515, in validate_no_atomic_block
    raise TransactionManagementError(
django.db.transaction.TransactionManagementError: This is forbidden when an 'atomic' block is active.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "C:\Users\Administrator\Documents\Repo-EAML-Core\tests\Tests All AI modules\unit\test_salaries_prediction.py", line 390, in test_salaries_prediction_diagnostic_row_count
    nn_engine = NNEngine(machine, allow_re_run_configuration=True)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\Repo-EAML-Core\ML\NNEngine.py", line 97, in __init__
    self._init_load_or_create_configuration( allow_re_run_configuration=allow_re_run_configuration )
  File "C:\Users\Administrator\Documents\Repo-EAML-Core\ML\NNEngine.py", line 271, in _init_load_or_create_configuration
    _c_full_df_user = self._machine.data_lines_read( ) # we have to use the full dataset because with a subset we could miss some labels or out of bound values
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\Repo-EAML-Core\ML\Machine.py", line 483, in data_lines_read
    return self.db_machine.read_data_lines_from_db(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\Repo-EAML-Core\models\machine.py", line 769, in read_data_lines_from_db
    return self.read_data_lines_from_db(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\Repo-EAML-Core\models\machine.py", line 782, in read_data_lines_from_db
    _df = pd.read_sql_query(_sql_query, connections["default"])
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py", line 528, in read_sql_query
    return pandas_sql.read_query(
           ^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py", line 2673, in execute
    raise ex from inner_exc
pandas.errors.DatabaseError: Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;
no such column: SepalLengthCm
unable to rollback
_________________________ TestMachine1.test_machine_1 _________________________

self = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
>               return self.cursor.execute(sql)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

ignored_wrapper_args = (False,
 {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
  'cursor': <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>})
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029495E56F00>
query = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, query, params=None):
        if params is None:
>           return super().execute(query)
                   ^^^^^^^^^^^^^^^^^^^^^^
E           sqlite3.OperationalError: no such column: SepalLengthCm

__class__  = <class 'django.db.backends.sqlite3.base.SQLiteCursorWrapper'>
params     = None
query      = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')
self       = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029495E56F00>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\sqlite3\base.py:356: OperationalError

The above exception was the direct cause of the following exception:

self = <pandas.io.sql.SQLiteDatabase object at 0x0000029508458B10>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql: str | Select | TextClause, params=None):
        if not isinstance(sql, str):
            raise TypeError("Query must be a string unless using sqlalchemy.")
        args = [] if params is None else [params]
        cur = self.con.cursor()
        try:
>           cur.execute(sql, *args)

args       = []
cur        = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
ex         = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
params     = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x0000029508458B10>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2664: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql, params=None):
>       return self._execute_with_wrappers(
            sql, params, many=False, executor=self._execute
        )

params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None, many = False
executor = <bound method CursorWrapper._execute of <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>>

    def _execute_with_wrappers(self, sql, params, many, executor):
        context = {"connection": self.db, "cursor": self}
        for wrapper in reversed(self.db.execute_wrappers):
            executor = functools.partial(wrapper, executor)
>       return executor(sql, params, many, context)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

context    = {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
 'cursor': <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>}
executor   = <bound method CursorWrapper._execute of <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>>
many       = False
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
>       with self.db.wrap_database_errors:

ignored_wrapper_args = (False,
 {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
  'cursor': <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>})
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.utils.DatabaseErrorWrapper object at 0x0000029492DCD2D0>
exc_type = <class 'sqlite3.OperationalError'>
exc_value = OperationalError('no such column: SepalLengthCm')
traceback = <traceback object at 0x000002950D918E00>

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is None:
            return
        for dj_exc_type in (
            DataError,
            OperationalError,
            IntegrityError,
            InternalError,
            ProgrammingError,
            NotSupportedError,
            DatabaseError,
            InterfaceError,
            Error,
        ):
            db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__)
            if issubclass(exc_type, db_exc_type):
                dj_exc_value = dj_exc_type(*exc_value.args)
                # Only set the 'errors_occurred' flag for errors that may make
                # the connection unusable.
                if dj_exc_type not in (DataError, IntegrityError):
                    self.wrapper.errors_occurred = True
>               raise dj_exc_value.with_traceback(traceback) from exc_value

db_exc_type = <class 'sqlite3.OperationalError'>
dj_exc_type = <class 'django.db.utils.OperationalError'>
dj_exc_value = OperationalError('no such column: SepalLengthCm')
exc_type   = <class 'sqlite3.OperationalError'>
exc_value  = OperationalError('no such column: SepalLengthCm')
self       = <django.db.utils.DatabaseErrorWrapper object at 0x0000029492DCD2D0>
traceback  = <traceback object at 0x000002950D918E00>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\utils.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
>               return self.cursor.execute(sql)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

ignored_wrapper_args = (False,
 {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>,
  'cursor': <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>})
params     = None
self       = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\utils.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029495E56F00>
query = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, query, params=None):
        if params is None:
>           return super().execute(query)
                   ^^^^^^^^^^^^^^^^^^^^^^
E           django.db.utils.OperationalError: no such column: SepalLengthCm

__class__  = <class 'django.db.backends.sqlite3.base.SQLiteCursorWrapper'>
params     = None
query      = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')
self       = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029495E56F00>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\sqlite3\base.py:356: OperationalError

During handling of the above exception, another exception occurred:

self = <pandas.io.sql.SQLiteDatabase object at 0x0000029508458B10>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql: str | Select | TextClause, params=None):
        if not isinstance(sql, str):
            raise TypeError("Query must be a string unless using sqlalchemy.")
        args = [] if params is None else [params]
        cur = self.con.cursor()
        try:
            cur.execute(sql, *args)
            return cur
        except Exception as exc:
            try:
>               self.con.rollback()

args       = []
cur        = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
ex         = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
params     = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x0000029508458B10>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = (<DatabaseWrapper vendor='sqlite' alias='default'>,), kwargs = {}

    @wraps(func)
    def inner(*args, **kwargs):
        # Detect a running event loop in this thread.
        try:
            get_running_loop()
        except RuntimeError:
            pass
        else:
            if not os.environ.get("DJANGO_ALLOW_ASYNC_UNSAFE"):
                raise SynchronousOnlyOperation(message)
        # Pass onward.
>       return func(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^

args       = (<DatabaseWrapper vendor='sqlite' alias='default'>,)
func       = <function BaseDatabaseWrapper.rollback at 0x000002943E4C9260>
kwargs     = {}
message    = 'You cannot call this from an async context - use a thread or sync_to_async.'

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\utils\asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DatabaseWrapper vendor='sqlite' alias='default'>

    @async_unsafe
    def rollback(self):
        """Roll back a transaction and reset the dirty flag."""
        self.validate_thread_sharing()
>       self.validate_no_atomic_block()

self       = <DatabaseWrapper vendor='sqlite' alias='default'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\base\base.py:336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DatabaseWrapper vendor='sqlite' alias='default'>

    def validate_no_atomic_block(self):
        """Raise an error if an atomic block is active."""
        if self.in_atomic_block:
>           raise TransactionManagementError(
                "This is forbidden when an 'atomic' block is active."
            )
E           django.db.transaction.TransactionManagementError: This is forbidden when an 'atomic' block is active.

self       = <DatabaseWrapper vendor='sqlite' alias='default'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\backends\base\base.py:515: TransactionManagementError

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029501D398A0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

cls        = <class '_pytest.runner.CallInfo'>
duration   = Duration(start=Instant(time=1763794746.820816, perf_count=186963.3905886),
         stop=Instant(time=1763794877.7883892, perf_count=187094.358646))
excinfo    = <ExceptionInfo DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Spec...4_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback') tblen=33>
func       = <function call_and_report.<locals>.<lambda> at 0x0000029501D398A0>
instant    = Instant(time=1763794746.820816, perf_count=186963.3905886)
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
when       = 'call'

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )

item       = <Function test_machine_1>
kwds       = {}
runtest_hook = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_machine_1>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
kwargs     = {'item': <Function test_machine_1>}
self       = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
kwargs = {'item': <Function test_machine_1>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
hook_name  = 'pytest_runtest_call'
kwargs     = {'item': <Function test_machine_1>}
methods    = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_1>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_machine_1>]
caller_kwargs = {'item': <Function test_machine_1>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6200>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6200>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF71F0>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF6200>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_1>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_machine_1>]
caller_kwargs = {'item': <Function test_machine_1>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6200>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6200>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF71F0>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF6200>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>
item = <Function test_machine_1>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")
    
        with self._runtest_for(item, "call"):
>           yield

item       = <Function test_machine_1>
self       = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\logging.py:850: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_1>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_machine_1>]
caller_kwargs = {'item': <Function test_machine_1>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6200>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6200>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF71F0>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF6200>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io...._io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_machine_1>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

item       = <Function test_machine_1>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\capture.py:900: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_1>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_machine_1>]
caller_kwargs = {'item': <Function test_machine_1>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6200>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6200>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF71F0>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF6200>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_machine_1>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

args       = [<Function test_machine_1>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x00000294E252C300>
teardown   = <generator object pytest_runtest_call at 0x000002943E8DFA40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x00000294E252C300>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

__tracebackhide__ = True
exc        = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
self       = <pluggy._result.Result object at 0x00000294E252C300>
tb         = <traceback object at 0x00000294E252C540>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_result.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_machine_1>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

args       = [<Function test_machine_1>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x00000294E252C300>
teardown   = <generator object pytest_runtest_call at 0x000002943E8DFA40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_1>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_machine_1>]
caller_kwargs = {'item': <Function test_machine_1>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6200>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6200>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF71F0>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF6200>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_machine_1>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)
    
        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)
    
        try:
>           return (yield)
                    ^^^^^

item       = <Function test_machine_1>
xfailed    = None

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\skipping.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_1>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_machine_1>]
caller_kwargs = {'item': <Function test_machine_1>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495EF6200>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495EF6200>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF6D40>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF71F0>,
 <generator object run_old_style_hookwrapper at 0x000002949426ED40>,
 <generator object pytest_runtest_call at 0x0000029495EF6200>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_machine_1>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

item       = <Function test_machine_1>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_machine_1>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

self       = <Function test_machine_1>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:1671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_machine_1>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
kwargs     = {'pyfuncitem': <Function test_machine_1>}
self       = <HookCaller 'pytest_pyfunc_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
kwargs = {'pyfuncitem': <Function test_machine_1>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
hook_name  = 'pytest_pyfunc_call'
kwargs     = {'pyfuncitem': <Function test_machine_1>}
methods    = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_machine_1>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_machine_1>]
caller_kwargs = {'pyfuncitem': <Function test_machine_1>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_machine_1>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_machine_1>]
caller_kwargs = {'pyfuncitem': <Function test_machine_1>}
exception  = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_machine_1>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

funcargs   = {'_dj_autoclear_mailbox': None,
 '_django_clear_site_cache': None,
 '_django_db_marker': None,
 '_django_set_urlconf': None,
 '_django_setup_unittest': None,
 '_fail_for_invalid_template_variable': None,
 '_live_server_helper': None,
 '_template_string_if_invalid_marker': None,
 'db_cleanup': None,
 'django_db_blocker': <pytest_django.plugin.DjangoDbBlocker object at 0x000002940D867690>,
 'django_test_environment': None,
 'monkeypatch': <_pytest.monkeypatch.MonkeyPatch object at 0x000002950D9AE410>,
 'request': <FixtureRequest for <Function test_machine_1>>,
 'session_test_database': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3',
 'test_database': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3',
 'test_database_source': 'C:\\Users\\Administrator\\Documents\\Repo-EAML-Core\\start_set_databases.sqlite3',
 'test_database_with_verification': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'}
pyfuncitem = <Function test_machine_1>
testargs   = {'test_database_with_verification': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'}
testfunction = <bound method TestMachine1.test_machine_1 of <unit.test_z_machine_1.TestMachine1 object at 0x000002949484EED0>>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unit.test_z_machine_1.TestMachine1 object at 0x000002949484EED0>
test_database_with_verification = 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'

    @pytest.mark.django_db
    def test_machine_1(self, test_database_with_verification):
        """
        Complete machine workflow test:
        1. Create machine from CSV file
        2. Test machine properties
        3. Create all configurations
        4. Run training
        5. Test solving
        """
        # Step 1: Create machine from CSV
        print('\n1. Creating machine from CSV file...')
        machine = self.create_machine_from_csv()
    
        # Step 2: Test machine properties
        print('\n2. Testing machine properties...')
        self._verify_machine_properties(machine)
    
        # Step 3: Create all configurations
        print('\n3. Creating all configurations...')
>       nn_engine = self.create_configurations(machine)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

machine    = <machine:904:__TEST_CMD__iris_flowers>
self       = <unit.test_z_machine_1.TestMachine1 object at 0x000002949484EED0>
test_database_with_verification = 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'

tests\Tests All AI modules\unit\test_z_machine_1.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unit.test_z_machine_1.TestMachine1 object at 0x000002949484EED0>
machine = <machine:904:__TEST_CMD__iris_flowers>

    def create_configurations(self, machine):
        """Create all machine configurations via NNEngine"""
        print('   Creating NNEngine (this will create all configurations)...')
    
        try:
>           nn_engine = NNEngine(machine, allow_re_run_configuration=True)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

machine    = <machine:904:__TEST_CMD__iris_flowers>
self       = <unit.test_z_machine_1.TestMachine1 object at 0x000002949484EED0>

tests\Tests All AI modules\unit\test_z_machine_1.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ML.NNEngine.NNEngine object at 0x00000295096CD690>
machine = <machine:904:__TEST_CMD__iris_flowers>
allow_re_run_configuration = True

    def __init__( self, machine: Machine, allow_re_run_configuration: bool = False ):
        """
        Create NNEngine or load it from Machine
        If configuration are available inside Machine we use it else we will generate it
    
        :param machine: the machine to work on
        """
        if not isinstance(machine, Machine):
            logger.error( "The constructor argument must have an instance of the machine" )
    
        self._machine = machine
        self._mdc = None
        self._ici = None
        self._fe = None
        self._enc_dec = None
        self._nn_configuration = None
        self._nn_model = None
    
        if IS_RUNNING_IN_DEBUG_MODE:
>           self._init_load_or_create_configuration( allow_re_run_configuration=allow_re_run_configuration )

allow_re_run_configuration = True
machine    = <machine:904:__TEST_CMD__iris_flowers>
self       = <ML.NNEngine.NNEngine object at 0x00000295096CD690>

ML\NNEngine.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ML.NNEngine.NNEngine object at 0x00000295096CD690>
allow_re_run_configuration = True, update_data_infos_stats = False

    def _init_load_or_create_configuration( self , allow_re_run_configuration: bool = False , update_data_infos_stats:bool=False ):
        """
        Create NNEngine or load it from Machine
        If configuration are available inside Machine we use it else we will generate it
    
        All configurations to run NNEngine will be prepared here
        NNEngine need to have all this configurations built : MDC, CI, FE, EncDec, NNConfiguration, NNModel
        We try to use the configuration stored into machine, if not available we will generate the configuration, using best if possible or else doing minimum_default
    
        at each step we load the configuration or we create the configuration and save it into machine object
        only last step : training nn model is not performed here (sometime we need nnengine for performing trial learning)
    
        Some flag can trigger some configuration to be rebuilt : re_run - If one Config need to be rebuilt then all following Config will be cleared and rebuilt
        """
    
        if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"NNEngine initializing (loading and/or creating) all configuration for {self._machine}" )
    
        db_machine = self._machine.db_machine
    
        # MDC and EncDec may load and use the dataset - we cache it for faster
        _c_full_df_user = None
        _c_full_df_pre_encoded = None
    
        if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"NNEngine Starting preparing all configurations. " )
        self.machine_nn_engine_configuration_set_starting( self._machine )
    
        # -----------------------------------------
        #  MDC
        # -----------------------------------------
        if not self._machine.is_config_ready_mdc() or (allow_re_run_configuration and db_machine.machine_is_re_run_mdc):
            _c_full_df_user = self._machine.data_lines_read( ) # we have to use the full dataset because with a subset we could miss some labels or out of bound values
            # We do not indicate what user choose because anyway the dataset is formatted and this 2 parameters are useless : decimal_separator  date_format
            self._mdc = MachineDataConfiguration(
                                                    self._machine,
                                                    _c_full_df_user,
                                                    force_create_with_this_inputs=self._machine.db_machine.mdc_columns_name_input,    # we cannot change this after creation
                                                    force_create_with_this_outputs=self._machine.db_machine.mdc_columns_name_output, # we cannot change this after creation
                                                    columns_type_user_df=self._machine.db_machine.dfr_columns_type_user_df,
                                                    columns_description_user_df= self._machine.db_machine.dfr_columns_description_user_df,
                                                    decimal_separator = ".",
                                                    date_format = "MDY" )
            self._mdc.save_configuration_in_machine( )
            # rerun configuration have been done, we can clear the flag
            db_machine.machine_is_re_run_mdc = False
    
            # configuration regenerated need to force following configurations to be rebuilt too
            self._machine.clear_config_ici( )
            self._machine.clear_config_fe( )
            self._machine.clear_config_enc_dec( )
            self._machine.clear_config_nn_configuration( )
            self._machine.clear_config_nn_model( )
    
        else:
            self._mdc = MachineDataConfiguration(self._machine)
            if update_data_infos_stats:
                _c_full_df_user = self._machine.data_lines_read( )  # we have to use the full dataset because with a subset we could miss some labels or out of bound values
                _c_full_df_pre_encoded = self._mdc.dataframe_pre_encode( _c_full_df_user )
                self._mdc._recalculate_data_infos_stats( _c_full_df_pre_encoded, decimal_separator = ".", date_format = "MDY" )
    
        # -----------------------------------------
        #  Column Importance
        # -----------------------------------------
        from ML.InputsColumnsImportance import InputsColumnsImportance
        if not self._machine.is_config_ready_ici( ) or (allow_re_run_configuration and db_machine.machine_is_re_run_ici):
            if (
                    not self._machine.is_config_ready_fe() or
                    not self._machine.is_config_ready_enc_dec() or
                    not self._machine.is_config_ready_nn_configuration() or
                    not self.is_nn_trained_and_ready()
                ):
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( "unable to do ICI best configuration because fe or encdec or nnconfig are not ready => doing minimum ICI" )
                self._ici = InputsColumnsImportance( self._machine , create_configuration_simple_minimum=True).save_configuration_in_machine()
                db_machine.machine_is_re_run_ici = True
            else:
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( "do ICI best configuration because fe or encdec or nnconfig are ready" )
                self._ici = InputsColumnsImportance( self._machine , create_configuration_best=True, nnengine_for_best_config=self ).save_configuration_in_machine()
                # rerun configuration have been done, we can clear the flag
                db_machine.machine_is_re_run_ici = False
    
            # configuration regenerated need to force following configurations to be rebuilt too
            self._machine.clear_config_fe( )
            self._machine.clear_config_enc_dec( )
            self._machine.clear_config_nn_configuration( )
            self._machine.clear_config_nn_model( )
    
        else:
            # load the configuration ICI by default if no force flag and if not needed by rerun to make configuration
             self._ici = InputsColumnsImportance( self._machine )
    
        # -----------------------------------------
        #  FE
        # -----------------------------------------
        from ML.FeatureEngineeringConfiguration import FeatureEngineeringConfiguration
        if not self._machine.is_config_ready_fe() or (allow_re_run_configuration and db_machine.machine_is_re_run_fe):
            if (
                    not self._machine.is_config_ready_enc_dec() or
                    not self._machine.is_config_ready_nn_configuration()
                    ):
                # generate the configuration FE MINIMUM because we cannot do FE_BEST now
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"generate the configuration FE MINIMUM because we cannot do FE_BEST now" )
                self._fe = FeatureEngineeringConfiguration(
                    machine=self._machine,
                    force_configuration_simple_minimum=True
                    ).save_configuration_in_machine()
                # we will do best FE later
                db_machine.machine_is_re_run_fe = True
            else:
                # generate the configuration FE BEST
                if ENABLE_LOGGER_DEBUG_NNEngine: logger.debug( f"generate the configuration FE BEST  " )
                db_machine.fe_budget_total = MachineLevel(self._machine).feature_engineering_budget()[1]
                # load (never do best config of course) the nnconfiguration that we will use to evaluate the FEC
                self._nn_configuration = NNConfiguration(self._machine)
                self._fe = FeatureEngineeringConfiguration(
                    machine=self._machine,
                    nn_engine_for_searching_best_config=self,
                    global_dataset_budget=self._machine.db_machine.fe_budget_total,
                    force_configuration_simple_minimum=False,
                    ).save_configuration_in_machine()
                # rerun configuration have been done, we can clear the flag
                db_machine.machine_is_re_run_fe = False
    
            #  configuration regenerated need to force following configurations to be rebuilt too
            self._machine.clear_config_enc_dec( )
            self._machine.clear_config_nn_configuration( )
            self._machine.clear_config_nn_model( )
    
        else:
            # load the configuration FE
            self._fe = FeatureEngineeringConfiguration(self._machine)
    
    
        # -----------------------------------------
        #  EncDec
        # -----------------------------------------
        if not self._machine.is_config_ready_enc_dec( ) or (allow_re_run_configuration and db_machine.machine_is_re_run_enc_dec):
            # generate configuration encdec
            if _c_full_df_pre_encoded is None:
                if _c_full_df_user is None:
>                   _c_full_df_user = self._machine.data_lines_read( ) # we have to use the full dataset because with a subset we could miss some labels or out of bound values
                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

FeatureEngineeringConfiguration = <class 'ML.FeatureEngineeringConfiguration.FeatureEngineeringConfiguration'>
InputsColumnsImportance = <class 'ML.InputsColumnsImportance.InputsColumnsImportance'>
_c_full_df_pre_encoded = None
_c_full_df_user = None
allow_re_run_configuration = True
db_machine = <Machine: <machine:904:__TEST_CMD__iris_flowers>>
self       = <ML.NNEngine.NNEngine object at 0x00000295096CD690>
update_data_infos_stats = False

ML\NNEngine.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <machine:904:__TEST_CMD__iris_flowers>, sort_by = ''
rows_count_limit = None, kwargs = {}

    def data_lines_read(
            self,
            sort_by: str = "",
            rows_count_limit: Optional[int ] = None,
            **kwargs,
    ) -> pd.DataFrame:
        """
        this method get the pandas dataframe which return inner join of two dataframe, one from data_input_lines_read
        and second from data_output_lines_read
    
        :params **kwargs: can be None or column_mode or status for lines
        :return: inner joined pandas dataframe
        """
>       return self.db_machine.read_data_lines_from_db(
            sort_by=sort_by,
            rows_count_limit=rows_count_limit,
            where_clause_dict=kwargs
        )

kwargs     = {}
rows_count_limit = None
self       = <machine:904:__TEST_CMD__iris_flowers>
sort_by    = ''

ML\Machine.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Machine: <machine:904:__TEST_CMD__iris_flowers>>, input_columns = None
output_columns = None, where_clause_dict = {}, sort_by = ''
rows_count_limit = None, is_random = False

    def read_data_lines_from_db(
        self,
        input_columns: list = None,
        output_columns: list = None,
        where_clause_dict: dict = None,
        sort_by: str = None,
        rows_count_limit: int = None,
        is_random: bool = False,
    ) -> pd.DataFrame:
    
        _where_clause_dict = {}
        if where_clause_dict:
            where_clause_dict_clean = {
                column_name: column_value
                for column_name, column_value in where_clause_dict.items()
                if column_name not in ("with_reserved_columns", "offset", "")
            }
            _where_clause_dict.update({column_name: "=1" for column_name, column_value in where_clause_dict_clean.items() if column_value is True})
            _where_clause_dict.update({column_name: "=0" for column_name, column_value in where_clause_dict_clean.items() if column_value is False})
    
        _limit_clause = f"LIMIT {rows_count_limit}" if rows_count_limit else ""
    
        if sort_by and is_random:
            logger.error("It is not possible to use simultaneously sort_by and is_random")
        elif sort_by:
            _sort_clause_direction = "DESC" if sort_by.startswith("-") else "ASC"
            _sort_clause = f"ORDER BY `{sort_by}` {_sort_clause_direction}"
        elif is_random:
            _sort_clause = "ORDER BY RAND()"
        else:
            _sort_clause = ""
    
        if isinstance(input_columns, list) and isinstance(output_columns, list) and len(input_columns) != 0 and len(output_columns) != 0:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])}, {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        elif isinstance(input_columns, list) and len(input_columns) != 0 and (output_columns is None or output_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])} FROM Machine_{self.id}_DataInputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and (input_columns is None or input_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} FROM Machine_{self.id}_DataOutputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and not input_columns and _where_clause_dict:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        else:
>           return self.read_data_lines_from_db(
                input_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_input_user_df.items() if column_direction
                ],
                output_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_output_user_df.items() if column_direction
                ],
                where_clause_dict=where_clause_dict,
                sort_by=sort_by,
                rows_count_limit=rows_count_limit,
                is_random=is_random,
            )

_limit_clause = ''
_sort_clause = ''
_where_clause_dict = {}
input_columns = None
is_random  = False
output_columns = None
rows_count_limit = None
self       = <Machine: <machine:904:__TEST_CMD__iris_flowers>>
sort_by    = ''
where_clause_dict = {}

models\machine.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Machine: <machine:904:__TEST_CMD__iris_flowers>>
input_columns = ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm', 'PetalWidthCm']
output_columns = ['Species'], where_clause_dict = {}, sort_by = ''
rows_count_limit = None, is_random = False

    def read_data_lines_from_db(
        self,
        input_columns: list = None,
        output_columns: list = None,
        where_clause_dict: dict = None,
        sort_by: str = None,
        rows_count_limit: int = None,
        is_random: bool = False,
    ) -> pd.DataFrame:
    
        _where_clause_dict = {}
        if where_clause_dict:
            where_clause_dict_clean = {
                column_name: column_value
                for column_name, column_value in where_clause_dict.items()
                if column_name not in ("with_reserved_columns", "offset", "")
            }
            _where_clause_dict.update({column_name: "=1" for column_name, column_value in where_clause_dict_clean.items() if column_value is True})
            _where_clause_dict.update({column_name: "=0" for column_name, column_value in where_clause_dict_clean.items() if column_value is False})
    
        _limit_clause = f"LIMIT {rows_count_limit}" if rows_count_limit else ""
    
        if sort_by and is_random:
            logger.error("It is not possible to use simultaneously sort_by and is_random")
        elif sort_by:
            _sort_clause_direction = "DESC" if sort_by.startswith("-") else "ASC"
            _sort_clause = f"ORDER BY `{sort_by}` {_sort_clause_direction}"
        elif is_random:
            _sort_clause = "ORDER BY RAND()"
        else:
            _sort_clause = ""
    
        if isinstance(input_columns, list) and isinstance(output_columns, list) and len(input_columns) != 0 and len(output_columns) != 0:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])}, {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        elif isinstance(input_columns, list) and len(input_columns) != 0 and (output_columns is None or output_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in input_columns])} FROM Machine_{self.id}_DataInputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and (input_columns is None or input_columns == []):
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} FROM Machine_{self.id}_DataOutputLines {_where_clause} {_sort_clause} {_limit_clause}"
    
        elif isinstance(output_columns, list) and len(output_columns) != 0 and not input_columns and _where_clause_dict:
            _where_clause = (
                "WHERE " + " AND ".join([f"{column_name}{column_clause}" for column_name, column_clause in _where_clause_dict.items()])
                if _where_clause_dict
                else ""
            )
    
            _sql_query = (
                f"SELECT {', '.join([f'`{column_name}`' for column_name in output_columns])} "
                f"FROM Machine_{self.id}_DataInputLines "
                f"LEFT JOIN Machine_{self.id}_DataOutputLines "
                f"ON Machine_{self.id}_DataInputLines.Line_ID = Machine_{self.id}_DataOutputLines.Line_ID "
                f"{_where_clause} "
                f"{_sort_clause} {_limit_clause};"
            )
    
        else:
            return self.read_data_lines_from_db(
                input_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_input_user_df.items() if column_direction
                ],
                output_columns=[
                    column_name for column_name, column_direction in self.mdc_columns_name_output_user_df.items() if column_direction
                ],
                where_clause_dict=where_clause_dict,
                sort_by=sort_by,
                rows_count_limit=rows_count_limit,
                is_random=is_random,
            )
    
>       _df = pd.read_sql_query(_sql_query, connections["default"])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_limit_clause = ''
_sort_clause = ''
_sql_query = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')
_where_clause = ''
_where_clause_dict = {}
input_columns = ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm', 'PetalWidthCm']
is_random  = False
output_columns = ['Species']
rows_count_limit = None
self       = <Machine: <machine:904:__TEST_CMD__iris_flowers>>
sort_by    = ''
where_clause_dict = {}

models\machine.py:782: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
con = <DatabaseWrapper vendor='sqlite' alias='default'>, index_col = None
coerce_float = True, params = None, parse_dates = None, chunksize = None
dtype = None, dtype_backend = 'numpy'

    def read_sql_query(
        sql,
        con,
        index_col: str | list[str] | None = None,
        coerce_float: bool = True,
        params: list[Any] | Mapping[str, Any] | None = None,
        parse_dates: list[str] | dict[str, str] | None = None,
        chunksize: int | None = None,
        dtype: DtypeArg | None = None,
        dtype_backend: DtypeBackend | lib.NoDefault = lib.no_default,
    ) -> DataFrame | Iterator[DataFrame]:
        """
        Read SQL query into a DataFrame.
    
        Returns a DataFrame corresponding to the result set of the query
        string. Optionally provide an `index_col` parameter to use one of the
        columns as the index, otherwise default integer index will be used.
    
        Parameters
        ----------
        sql : str SQL query or SQLAlchemy Selectable (select or text object)
            SQL query to be executed.
        con : SQLAlchemy connectable, str, or sqlite3 connection
            Using SQLAlchemy makes it possible to use any DB supported by that
            library. If a DBAPI2 object, only sqlite3 is supported.
        index_col : str or list of str, optional, default: None
            Column(s) to set as index(MultiIndex).
        coerce_float : bool, default True
            Attempts to convert values of non-string, non-numeric objects (like
            decimal.Decimal) to floating point. Useful for SQL result sets.
        params : list, tuple or mapping, optional, default: None
            List of parameters to pass to execute method.  The syntax used
            to pass parameters is database driver dependent. Check your
            database driver documentation for which of the five syntax styles,
            described in PEP 249's paramstyle, is supported.
            Eg. for psycopg2, uses %(name)s so use params={'name' : 'value'}.
        parse_dates : list or dict, default: None
            - List of column names to parse as dates.
            - Dict of ``{column_name: format string}`` where format string is
              strftime compatible in case of parsing string times, or is one of
              (D, s, ns, ms, us) in case of parsing integer timestamps.
            - Dict of ``{column_name: arg dict}``, where the arg dict corresponds
              to the keyword arguments of :func:`pandas.to_datetime`
              Especially useful with databases without native Datetime support,
              such as SQLite.
        chunksize : int, default None
            If specified, return an iterator where `chunksize` is the number of
            rows to include in each chunk.
        dtype : Type name or dict of columns
            Data type for data or columns. E.g. np.float64 or
            {'a': np.float64, 'b': np.int32, 'c': 'Int64'}.
    
            .. versionadded:: 1.3.0
        dtype_backend : {'numpy_nullable', 'pyarrow'}, default 'numpy_nullable'
            Back-end data type applied to the resultant :class:`DataFrame`
            (still experimental). Behaviour is as follows:
    
            * ``"numpy_nullable"``: returns nullable-dtype-backed :class:`DataFrame`
              (default).
            * ``"pyarrow"``: returns pyarrow-backed nullable :class:`ArrowDtype`
              DataFrame.
    
            .. versionadded:: 2.0
    
        Returns
        -------
        DataFrame or Iterator[DataFrame]
    
        See Also
        --------
        read_sql_table : Read SQL database table into a DataFrame.
        read_sql : Read SQL query or database table into a DataFrame.
    
        Notes
        -----
        Any datetime values with time zone information parsed via the `parse_dates`
        parameter will be converted to UTC.
    
        Examples
        --------
        >>> from sqlalchemy import create_engine  # doctest: +SKIP
        >>> engine = create_engine("sqlite:///database.db")  # doctest: +SKIP
        >>> with engine.connect() as conn, conn.begin():  # doctest: +SKIP
        ...     data = pd.read_sql_table("data", conn)  # doctest: +SKIP
        """
    
        check_dtype_backend(dtype_backend)
        if dtype_backend is lib.no_default:
            dtype_backend = "numpy"  # type: ignore[assignment]
        assert dtype_backend is not lib.no_default
    
        with pandasSQL_builder(con) as pandas_sql:
>           return pandas_sql.read_query(
                sql,
                index_col=index_col,
                params=params,
                coerce_float=coerce_float,
                parse_dates=parse_dates,
                chunksize=chunksize,
                dtype=dtype,
                dtype_backend=dtype_backend,
            )

chunksize  = None
coerce_float = True
con        = <DatabaseWrapper vendor='sqlite' alias='default'>
dtype      = None
dtype_backend = 'numpy'
index_col  = None
pandas_sql = <pandas.io.sql.SQLiteDatabase object at 0x0000029508458B10>
params     = None
parse_dates = None
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pandas.io.sql.SQLiteDatabase object at 0x0000029508458B10>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
index_col = None, coerce_float = True, parse_dates = None, params = None
chunksize = None, dtype = None, dtype_backend = 'numpy'

    def read_query(
        self,
        sql,
        index_col=None,
        coerce_float: bool = True,
        parse_dates=None,
        params=None,
        chunksize: int | None = None,
        dtype: DtypeArg | None = None,
        dtype_backend: DtypeBackend | Literal["numpy"] = "numpy",
    ) -> DataFrame | Iterator[DataFrame]:
>       cursor = self.execute(sql, params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

chunksize  = None
coerce_float = True
dtype      = None
dtype_backend = 'numpy'
index_col  = None
params     = None
parse_dates = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x0000029508458B10>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pandas.io.sql.SQLiteDatabase object at 0x0000029508458B10>
sql = 'SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;'
params = None

    def execute(self, sql: str | Select | TextClause, params=None):
        if not isinstance(sql, str):
            raise TypeError("Query must be a string unless using sqlalchemy.")
        args = [] if params is None else [params]
        cur = self.con.cursor()
        try:
            cur.execute(sql, *args)
            return cur
        except Exception as exc:
            try:
                self.con.rollback()
            except Exception as inner_exc:  # pragma: no cover
                ex = DatabaseError(
                    f"Execution failed on sql: {sql}\n{exc}\nunable to rollback"
                )
>               raise ex from inner_exc
E               pandas.errors.DatabaseError: Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;
E               no such column: SepalLengthCm
E               unable to rollback

args       = []
cur        = <django.db.backends.utils.CursorWrapper object at 0x00000295024E4190>
ex         = DatabaseError('Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;\nno such column: SepalLengthCm\nunable to rollback')
params     = None
self       = <pandas.io.sql.SQLiteDatabase object at 0x0000029508458B10>
sql        = ('SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, '
 '`Species` FROM Machine_904_DataInputLines LEFT JOIN '
 'Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = '
 'Machine_904_DataOutputLines.Line_ID   ;')

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pandas\io\sql.py:2673: DatabaseError
---------------------------- Captured stdout call -----------------------------

1. Creating machine from CSV file...
   Reading CSV file: C:\Users\Administrator\Documents\Repo-EAML-Core\tests\Tests All AI modules\Test Data - Iris flowers.csv
   Dataframe shape: (150, 5)
   Columns: ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm', 'PetalWidthCm', 'Species']
    Machine created with ID: 904
   Machine name: __TEST_CMD__iris_flowers

2. Testing machine properties...
   Machine ID: 904
   Machine name: __TEST_CMD__iris_flowers
   Machine level: 1
   Input lines: 0
   Output lines: 0
   MDC ready: <bound method Machine.is_config_ready_mdc of <machine:904:__TEST_CMD__iris_flowers>>
   ICI ready: <bound method Machine.is_config_ready_ici of <machine:904:__TEST_CMD__iris_flowers>>
   FE ready: <bound method Machine.is_config_ready_fe of <machine:904:__TEST_CMD__iris_flowers>>
   EncDec ready: <bound method Machine.is_config_ready_enc_dec of <machine:904:__TEST_CMD__iris_flowers>>
   NN Config ready: <bound method Machine.is_config_ready_nn_configuration of <machine:904:__TEST_CMD__iris_flowers>>
   NN Model ready: <bound method Machine.is_config_ready_nn_model of <machine:904:__TEST_CMD__iris_flowers>>
    All machine properties accessible

3. Creating all configurations...
   Creating NNEngine (this will create all configurations)...
    Failed to create NNEngine: Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;
no such column: SepalLengthCm
unable to rollback
---------------------------- Captured stderr call -----------------------------
[34mDEBUG   |<frozen runpy>|Creating DFR from C:\Users\Administrator\Documents\Repo-EAML-Core\tests\Tests All AI modules\Test Data - Iris flowers.csv[0m
[34mDEBUG   |<frozen runpy>|Analysing column : SepalLengthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : SepalWidthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : PetalLengthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : PetalWidthCm -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : Species -> DatasetColumnDataType.LABEL[0m
[34mDEBUG   |<frozen runpy>|Reformat DF : 150 rows X 5 cols [0m
[34mDEBUG   |<frozen runpy>|Creation __TEST_CMD__iris_flowers by DFR [0m
[34mDEBUG   |<frozen runpy>|Creation MachineDataConfiguration from user dataset[0m
[34mDEBUG   |<frozen runpy>|MDC saving configuration full[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine: Empty machine> on disk[0m
[34mDEBUG   |<frozen runpy>|Create_data_tables for <machine:904:__TEST_CMD__iris_flowers> started[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataInputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataInputLines" (
	"Line_ID" BIGINT, 
	"SepalLengthCm" FLOAT, 
	"SepalWidthCm" FLOAT, 
	"PetalLengthCm" FLOAT, 
	"PetalWidthCm" FLOAT, 
	"IsForLearning" BOOLEAN, 
	"IsForSolving" BOOLEAN, 
	"IsForEvaluation" BOOLEAN, 
	"IsLearned" BOOLEAN, 
	"IsSolved" BOOLEAN
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data input lines was appended. First_new_row_id:1 with arguments:{}[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataOutputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataOutputLines" (
	"Line_ID" BIGINT, 
	"Species" TEXT
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data output lines was appended[0m
[34mDEBUG   |<frozen runpy>|data_lines_appended      SepalLengthCm  SepalWidthCm  PetalLengthCm  PetalWidthCm         Species
0              5.1           3.5            1.4           0.2     Iris-setosa
1              4.9           3.0            1.4           0.2     Iris-setosa
2              4.7           3.2            1.3           0.2     Iris-setosa
3              4.6           3.1            1.5           0.2     Iris-setosa
4              5.0           3.6            1.4           0.2     Iris-setosa
..             ...           ...            ...           ...             ...
145            6.7           3.0            5.2           2.3  Iris-virginica
146            6.3           2.5            5.0           1.9  Iris-virginica
147            6.5           3.0            5.2           2.0  Iris-virginica
148            6.2           3.4            5.4           2.3  Iris-virginica
149            5.9           3.0            5.1           1.8  Iris-virginica

[150 rows x 5 columns] rows, with kwarg:{'machine_description': 'Test machine for Iris flowers dataset'} [0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_CMD__iris_flowers> on disk[0m
[34mDEBUG   |<frozen runpy>|Machine created and saved : <machine:904:__TEST_CMD__iris_flowers>[0m
[34mDEBUG   |<frozen runpy>|Saving <machine:904:__TEST_CMD__iris_flowers> on disk[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_CMD__iris_flowers> on disk[0m
[34mDEBUG   |<frozen runpy>|NNEngine initializing (loading and/or creating) all configuration for <machine:904:__TEST_CMD__iris_flowers>[0m
[34mDEBUG   |<frozen runpy>|NNEngine Starting preparing all configurations. [0m
[34mDEBUG   |<frozen runpy>|Loading MachineDataConfiguration for <machine:904:__TEST_CMD__iris_flowers> starting[0m
[34mDEBUG   |<frozen runpy>|unable to do ICI best configuration because fe or encdec or nnconfig are not ready => doing minimum ICI[0m
[34mDEBUG   |<frozen runpy>|_generate_configuration_default_minimum for <machine:904:__TEST_CMD__iris_flowers> done[0m
[34mDEBUG   |<frozen runpy>|Updated column importance for machine_source <machine:904:__TEST_CMD__iris_flowers>[0m
[34mDEBUG   |<frozen runpy>|generate the configuration FE MINIMUM because we cannot do FE_BEST now[0m
[34mDEBUG   |<frozen runpy>|Creation FEC Minimum for <machine:904:__TEST_CMD__iris_flowers> starting...[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalLengthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalLengthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalWidthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'SepalWidthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalLengthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalLengthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalWidthCm' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'PetalWidthCm' FEC to (['FETNumericStandardFloat'])[0m
[34mDEBUG   |<frozen runpy>|Set column 'Species' FEC to minimum[0m
[34mDEBUG   |<frozen runpy>|Set column 'Species' FEC to (['FETNumericStandardLabel'])[0m
[32mINFO    |<frozen runpy>|Done FEC with force_configuration_simple_minimum=True[0m
[34mDEBUG   |<frozen runpy>|Saving FeatureEngineeringConfiguration in <machine:904:__TEST_CMD__iris_flowers> [0m
______________ TestMachine2.test_machine_2_experimenter_workflow ______________

cls = <class 'models.user.User'>

    @classmethod
    def get_super_admin(cls):
        try:
>           admin = cls.objects.get(email=SUPER_ADMIN_EASYAUTOML_EMAIL)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cls        = <class 'models.user.User'>

models\user.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <models.user.UserManager object at 0x0000029520352BD0>, args = ()
kwargs = {'email': 'SuperAdmin@easyautoml.com'}

    @wraps(method)
    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

args       = ()
kwargs     = {'email': 'SuperAdmin@easyautoml.com'}
name       = 'get'
self       = <models.user.UserManager object at 0x0000029520352BD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\models\manager.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <QuerySet [<User: Admin User SuperSuperAdmin@easyautoml.com>]>, args = ()
kwargs = {'email': 'SuperAdmin@easyautoml.com'}, clone = <QuerySet []>
limit = 21, num = 0

    def get(self, *args, **kwargs):
        """
        Perform the query and return a single object matching the given
        keyword arguments.
        """
        if self.query.combinator and (args or kwargs):
            raise NotSupportedError(
                "Calling QuerySet.get(...) with filters after %s() is not "
                "supported." % self.query.combinator
            )
        clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)
        if self.query.can_filter() and not self.query.distinct_fields:
            clone = clone.order_by()
        limit = None
        if (
            not clone.query.select_for_update
            or connections[clone.db].features.supports_select_for_update_with_limit
        ):
            limit = MAX_GET_RESULTS
            clone.query.set_limits(high=limit)
        num = len(clone)
        if num == 1:
            return clone._result_cache[0]
        if not num:
>           raise self.model.DoesNotExist(
                "%s matching query does not exist." % self.model._meta.object_name
            )
E           models.user.User.DoesNotExist: User matching query does not exist.

args       = ()
clone      = <QuerySet []>
kwargs     = {'email': 'SuperAdmin@easyautoml.com'}
limit      = 21
num        = 0
self       = <QuerySet [<User: Admin User SuperSuperAdmin@easyautoml.com>]>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\django\db\models\query.py:633: DoesNotExist

During handling of the above exception, another exception occurred:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029495F2B2E0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

cls        = <class '_pytest.runner.CallInfo'>
duration   = Duration(start=Instant(time=1763794878.0335202, perf_count=187094.6033548),
         stop=Instant(time=1763794878.0685215, perf_count=187094.6385785))
excinfo    = <ExceptionInfo ValueError("Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database") tblen=26>
func       = <function call_and_report.<locals>.<lambda> at 0x0000029495F2B2E0>
instant    = Instant(time=1763794878.0335202, perf_count=187094.6033548)
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
when       = 'call'

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )

item       = <Function test_machine_2_experimenter_workflow>
kwds       = {}
runtest_hook = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
kwargs     = {'item': <Function test_machine_2_experimenter_workflow>}
self       = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
hook_name  = 'pytest_runtest_call'
kwargs     = {'item': <Function test_machine_2_experimenter_workflow>}
methods    = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_machine_2_experimenter_workflow>]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
exception  = ValueError("Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495F1BA60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495F1BA60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF5E40>,
 <generator object run_old_style_hookwrapper at 0x0000029494690700>,
 <generator object pytest_runtest_call at 0x0000029495F1BA60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_machine_2_experimenter_workflow>]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
exception  = ValueError("Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495F1BA60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495F1BA60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF5E40>,
 <generator object run_old_style_hookwrapper at 0x0000029494690700>,
 <generator object pytest_runtest_call at 0x0000029495F1BA60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>
item = <Function test_machine_2_experimenter_workflow>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")
    
        with self._runtest_for(item, "call"):
>           yield

item       = <Function test_machine_2_experimenter_workflow>
self       = <_pytest.logging.LoggingPlugin object at 0x000002943E454150>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\logging.py:850: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_machine_2_experimenter_workflow>]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
exception  = ValueError("Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495F1BA60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495F1BA60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF5E40>,
 <generator object run_old_style_hookwrapper at 0x0000029494690700>,
 <generator object pytest_runtest_call at 0x0000029495F1BA60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io...._io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_machine_2_experimenter_workflow>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

item       = <Function test_machine_2_experimenter_workflow>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\capture.py:900: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_machine_2_experimenter_workflow>]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
exception  = ValueError("Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495F1BA60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495F1BA60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF5E40>,
 <generator object run_old_style_hookwrapper at 0x0000029494690700>,
 <generator object pytest_runtest_call at 0x0000029495F1BA60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_machine_2_experimenter_workflow>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

args       = [<Function test_machine_2_experimenter_workflow>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x0000029565A084C0>
teardown   = <generator object pytest_runtest_call at 0x0000029495F1C140>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x0000029565A084C0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

__tracebackhide__ = True
exc        = ValueError("Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database")
self       = <pluggy._result.Result object at 0x0000029565A084C0>
tb         = <traceback object at 0x0000029565A08240>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_result.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_machine_2_experimenter_workflow>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

args       = [<Function test_machine_2_experimenter_workflow>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x0000029565A084C0>
teardown   = <generator object pytest_runtest_call at 0x0000029495F1C140>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_machine_2_experimenter_workflow>]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
exception  = ValueError("Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495F1BA60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495F1BA60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF5E40>,
 <generator object run_old_style_hookwrapper at 0x0000029494690700>,
 <generator object pytest_runtest_call at 0x0000029495F1BA60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_machine_2_experimenter_workflow>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)
    
        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)
    
        try:
>           return (yield)
                    ^^^^^

item       = <Function test_machine_2_experimenter_workflow>
xfailed    = None

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\skipping.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_machine_2_experimenter_workflow>]
caller_kwargs = {'item': <Function test_machine_2_experimenter_workflow>}
exception  = ValueError("Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database")
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x0000029495F1BA60>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x0000029409706390>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002940D84B090>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002943E454150>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x0000029495F1BA60>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x0000029495EF4310>,
 <generator object CaptureManager.pytest_runtest_call at 0x0000029495EF5E40>,
 <generator object run_old_style_hookwrapper at 0x0000029494690700>,
 <generator object pytest_runtest_call at 0x0000029495F1BA60>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_machine_2_experimenter_workflow>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

item       = <Function test_machine_2_experimenter_workflow>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_machine_2_experimenter_workflow>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

self       = <Function test_machine_2_experimenter_workflow>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:1671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_machine_2_experimenter_workflow>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
kwargs     = {'pyfuncitem': <Function test_machine_2_experimenter_workflow>}
self       = <HookCaller 'pytest_pyfunc_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
kwargs = {'pyfuncitem': <Function test_machine_2_experimenter_workflow>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
hook_name  = 'pytest_pyfunc_call'
kwargs     = {'pyfuncitem': <Function test_machine_2_experimenter_workflow>}
methods    = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000029408579FD0>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_machine_2_experimenter_workflow>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_machine_2_experimenter_workflow>]
caller_kwargs = {'pyfuncitem': <Function test_machine_2_experimenter_workflow>}
exception  = ValueError("Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database")
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_machine_2_experimenter_workflow>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_machine_2_experimenter_workflow>]
caller_kwargs = {'pyfuncitem': <Function test_machine_2_experimenter_workflow>}
exception  = ValueError("Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database")
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_machine_2_experimenter_workflow>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

funcargs   = {'_dj_autoclear_mailbox': None,
 '_django_clear_site_cache': None,
 '_django_db_marker': None,
 '_django_set_urlconf': None,
 '_django_setup_unittest': None,
 '_fail_for_invalid_template_variable': None,
 '_live_server_helper': None,
 '_template_string_if_invalid_marker': None,
 'db_cleanup': None,
 'django_db_blocker': <pytest_django.plugin.DjangoDbBlocker object at 0x000002940D867690>,
 'django_test_environment': None,
 'monkeypatch': <_pytest.monkeypatch.MonkeyPatch object at 0x0000029565A09710>,
 'request': <FixtureRequest for <Function test_machine_2_experimenter_workflow>>,
 'session_test_database': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3',
 'test_database': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3',
 'test_database_source': 'C:\\Users\\Administrator\\Documents\\Repo-EAML-Core\\start_set_databases.sqlite3',
 'test_database_with_verification': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'}
pyfuncitem = <Function test_machine_2_experimenter_workflow>
testargs   = {'test_database_with_verification': 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'}
testfunction = <bound method TestMachine2.test_machine_2_experimenter_workflow of <unit.test_z_machine_2.TestMachine2 object at 0x0000029494890350>>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unit.test_z_machine_2.TestMachine2 object at 0x0000029494890350>
test_database_with_verification = 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'

    @pytest.mark.django_db
    def test_machine_2_experimenter_workflow(self, test_database_with_verification):
        """
        Complete MachineEasyAutoML with Experimenter workflow test:
        1. Create SimpleExperimenter
        2. Create MachineEasyAutoML with experimenter (no initial data)
        3. Test predictions BEFORE training (using experimenter only)
        4. Train the machine
        5. Test predictions AFTER training (using trained model)
        6. Compare results and verify improvement
        """
        # Get admin user
        test_user = get_admin_user()
        if test_user is None:
            from django.contrib.auth import get_user_model
            User = get_user_model()
            test_user = User.objects.get(email='SuperSuperAdmin@easyautoml.com')
    
        print('\n' + '=' * 80)
        print('TEST MACHINE 2: MachineEasyAutoML with Experimenter Workflow')
        print('=' * 80)
        print('')
    
        # Step 1: Create experimenter
        print('Step 1: Creating SimpleExperimenter...')
        experimenter = SimpleExperimenter()
        print(' Created SimpleExperimenter')
        print('')
    
        # Step 2: Create MachineEasyAutoML with experimenter (no initial data)
        machine_name = "__TEST_CMD2__formula_machine"
        print(f'Step 2: Creating MachineEasyAutoML: {machine_name}')
    
>       machine_eaml = MachineEasyAutoML(
            machine_name=machine_name,
            optional_experimenter=experimenter,
            record_experiments=True,
            access_user_id=test_user.id,
            access_team_id=1,
        )

experimenter = <unit.test_z_machine_2.SimpleExperimenter object at 0x0000029565A0A010>
machine_name = '__TEST_CMD2__formula_machine'
self       = <unit.test_z_machine_2.TestMachine2 object at 0x0000029494890350>
test_database_with_verification = 'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\session_test_db_hlc5s1rj.sqlite3'
test_user  = <User: Admin User SuperSuperAdmin@easyautoml.com>

tests\Tests All AI modules\unit\test_z_machine_2.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'MachineEasyAutoML' object has no attribute '_machine_name'") raised in repr()] MachineEasyAutoML object at 0x29565a09ad0>
machine_name = '__TEST_CMD2__formula_machine'
optional_experimenter = <unit.test_z_machine_2.SimpleExperimenter object at 0x0000029565A0A010>
record_experiments = True, access_user_id = 1, access_team_id = 1
decimal_separator = '.', date_format = 'MDY'

    def __init__( self,
                        machine_name: str,
                        optional_experimenter: Optional = None,
                        record_experiments: bool = True,
                        access_user_id: int = None,
                        access_team_id: int = None,
                        decimal_separator : str = ".",
                        date_format : str = "MDY",
    ):
        """
        Creates a new MachineEasyAutoML object with given name
    
        :param machine_name: name of MachineEasyAutoML, if there is no machine_source created yet on deletion of this class machine_source will
            be created with this name, if machine_source exists machine_source with this name will be loaded
        :param optional_experimenter: when machine_source is not created or not trained yet, MachineEasyAutoML will use
            experimenter to predict instead. You can provide an 'Experimenter' instance to use experimenter. If this argument is None,
            MachineEasyAutoML will always return None in do_predict
    
        :param record_experiments: indicates whether to record predictions of experimenter
            if True predictions of experimenter will all be recorded and saved to the machine_source
    
        :param access_user_id: ID of machine_source owner
    
        """
        from ML import Machine
    
        if machine_name.startswith( "__") or machine_name.endswith( "__"):
            # only EasyAutoML Admin Team can create machine with __ so we know the user/team
>           self._current_access_user_id =  EasyAutoMLDBModels( ).User.get_super_admin( ).id
                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Machine    = <class 'ML.Machine.Machine'>
access_team_id = 1
access_user_id = 1
date_format = 'MDY'
decimal_separator = '.'
machine_name = '__TEST_CMD2__formula_machine'
optional_experimenter = <unit.test_z_machine_2.SimpleExperimenter object at 0x0000029565A0A010>
record_experiments = True
self       = <[AttributeError("'MachineEasyAutoML' object has no attribute '_machine_name'") raised in repr()] MachineEasyAutoML object at 0x29565a09ad0>

ML\MachineEasyAutoML.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'models.user.User'>

    @classmethod
    def get_super_admin(cls):
        try:
            admin = cls.objects.get(email=SUPER_ADMIN_EASYAUTOML_EMAIL)
        except Exception:
            # Use warning instead of error to avoid automatic exception raising
            _logger.warning(f"Unable to find super admin '{SUPER_ADMIN_EASYAUTOML_EMAIL}' in the user database")
>           raise ValueError(f"Unable to find super admin '{SUPER_ADMIN_EASYAUTOML_EMAIL}' in the user database")
E           ValueError: Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database

cls        = <class 'models.user.User'>

models\user.py:161: ValueError
---------------------------- Captured stdout call -----------------------------

================================================================================
TEST MACHINE 2: MachineEasyAutoML with Experimenter Workflow
================================================================================

Step 1: Creating SimpleExperimenter...
 Created SimpleExperimenter

Step 2: Creating MachineEasyAutoML: __TEST_CMD2__formula_machine
---------------------------- Captured stderr call -----------------------------
[33mWARNING |<frozen runpy>|Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database[0m
=========================== short test summary info ===========================
FAILED tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoML::test_easy_automl_get_status - AssertionError: assert 'status' in 'assert false\n +  where false = isinstance(none, bool)'
 +  where 'assert false\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x0000029520C9D300>()
 +    where <built-in method lower of str object at 0x0000029520C9D300> = 'assert False\n +  where False = isinstance(None, bool)'.lower
 +      where 'assert False\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\n +  where False = isinstance(None, bool)'))
FAILED tests/Tests All AI modules/unit/test_machine_easy_automl.py::TestMachineEasyAutoMLAPI::test_easy_automl_api_get_status - AssertionError: assert 'status' in 'assert false\n +  where false = isinstance(none, bool)'
 +  where 'assert false\n +  where false = isinstance(none, bool)' = <built-in method lower of str object at 0x00000295211A15A0>()
 +    where <built-in method lower of str object at 0x00000295211A15A0> = 'assert False\n +  where False = isinstance(None, bool)'.lower
 +      where 'assert False\n +  where False = isinstance(None, bool)' = str(AssertionError('assert False\n +  where False = isinstance(None, bool)'))
FAILED tests/Tests All AI modules/unit/test_salaries_prediction.py::TestSalariesPrediction::test_salaries_prediction_complete_workflow - pandas.errors.DatabaseError: Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;
no such column: SepalLengthCm
unable to rollback
FAILED tests/Tests All AI modules/unit/test_salaries_prediction.py::TestSalariesPrediction::test_salaries_prediction_diagnostic_row_count - pandas.errors.DatabaseError: Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;
no such column: SepalLengthCm
unable to rollback
FAILED tests/Tests All AI modules/unit/test_z_machine_1.py::TestMachine1::test_machine_1 - pandas.errors.DatabaseError: Execution failed on sql: SELECT `SepalLengthCm`, `SepalWidthCm`, `PetalLengthCm`, `PetalWidthCm`, `Species` FROM Machine_904_DataInputLines LEFT JOIN Machine_904_DataOutputLines ON Machine_904_DataInputLines.Line_ID = Machine_904_DataOutputLines.Line_ID   ;
no such column: SepalLengthCm
unable to rollback
FAILED tests/Tests All AI modules/unit/test_z_machine_2.py::TestMachine2::test_machine_2_experimenter_workflow - ValueError: Unable to find super admin 'SuperAdmin@easyautoml.com' in the user database
================= 6 failed, 198 passed in 14710.15s (4:05:10) =================
