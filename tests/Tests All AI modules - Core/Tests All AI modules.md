# Tests All AI modules

This directory contains comprehensive tests for all ML (Machine Learning) modules using pytest.

## Overview

This document explains how the unit testing system works, including how tests use temporary copies of the test database and how to run tests effectively.

### Quick Start

Run all tests from the project root directory:

```bash
# Run all tests
python -m pytest "tests/Tests All AI modules/unit" -v

# Run a specific test file
python -m pytest "tests/Tests All AI modules/unit/test_machine.py" -v

# Run with coverage report
python -m pytest "tests/Tests All AI modules/unit" --cov=ML --cov-report=html
```

### Key Features

✅ **Automatic database isolation** - Each test gets its own temporary database copy  
✅ **Comprehensive fixtures** - Reusable test data generators  
✅ **112 trained machines** - Pre-populated test database with realistic data  
✅ **Fast execution** - Optimized for quick feedback  
✅ **Easy debugging** - Clear error messages and test names

## Test Structure

```
Tests All AI modules/
├── conftest.py                    # Pytest configuration and fixtures
├── fixtures/
│   ├── __init__.py
│   └── test_data_generator.py    # Synthetic test data generators
└── unit/
    ├── __init__.py
    ├── test_database_integrity.py        # Database integrity verification tests
    ├── test_dependencies.py               # Dependency checks
    ├── test_eaml_db_models.py            # EasyAutoML_DB_Models.py tests
    ├── test_encdec.py                     # EncDec.py tests
    ├── test_feature_engineering_configuration.py # FeatureEngineeringConfiguration.py tests
    ├── test_inputs_columns_importance.py  # InputsColumnsImportance.py tests
    ├── test_machine.py                    # Machine.py tests
    ├── test_machine_1.py                  # Complete machine workflow tests
    ├── test_machine_2.py                  # MachineEasyAutoML with Experimenter workflow tests
    ├── test_machine_data_configuration.py # MachineDataConfiguration.py tests
    ├── test_machine_easy_automl.py        # MachineEasyAutoML.py tests
    ├── test_nn_configuration.py           # NNConfiguration.py tests
    ├── test_nn_engine.py                  # NNEngine.py tests
    ├── test_salaries_prediction.py        # Salaries prediction dataset workflow tests
    ├── test_solution_finder.py            # SolutionFinder.py tests
    └── test_solution_score.py             # SolutionScore.py tests
```

## Test Features

- **Simple & Fast**: Each test focuses on one function/behavior
- **Isolated**: Tests don't depend on each other
- **Cleanup**: Always delete test data after completion
- **Synthetic Data**: Use minimal generated data (not large CSV files)
- **Clear Names**: Test names describe what they test
- **Fixtures**: Reuse common setup via pytest fixtures

## Test Data

Tests use synthetic data generated by `TestDataGenerator` class:
- Small datasets (10-50 rows, 3-5 columns)
- Mixed data types (numeric, categorical, boolean, text)
- Missing values handling
- JSON column support

## Database Cleanup

All tests automatically clean up test data using the `db_cleanup` fixture:
- Deletes machines with names starting with `__TEST_UNIT__`
- Runs after each test
- Prevents test data accumulation

## Test Database System

### Database Source

All unit tests use a pre-populated SQLite database located at:
```
start_set_databases.sqlite3
```

This database contains:
- **321 tables** including main tables and machine-specific data tables
- **112 trained machines** ready for testing
- **469 neural network models**
- **2,514 encdec configurations**
- Complete machine data structures for comprehensive testing

### Automatic Database Copying

**Every test gets its own temporary copy** of the test database automatically. This ensures:
1. Tests don't interfere with each other
2. The original database is never modified
3. Parallel test execution is safe
4. Tests have access to realistic, pre-trained machines

### How It Works

1. **Before each test**: A temporary SQLite file is created
2. **Database copying**: The populated test database is copied to the temporary location
3. **Django configuration**: Django is configured to use the temporary database
4. **Test execution**: The test runs against this isolated copy
5. **Cleanup**: The temporary database is automatically deleted after the test

## Running Tests

### Prerequisites

Ensure you have:
1. Python 3.11+ with all dependencies installed
2. The test database file exists at: `start_set_databases.sqlite3` (in project root)
3. Proper Django configuration

### Database Integrity Tests

Before running actual unit tests, there are **pre-test verification tests** and **5 database integrity tests** that verify the test database structure:

**Pre-test Verification Tests:**
1. **`test_pretest_00_django_models_import`**
   - Verifies Django models can be imported correctly

2. **`test_pretest_01_django_models_relationships`**
   - Verifies Django model relationships are properly configured

3. **`test_pretest_02_database_copy_creation`**
   - Verifies temporary database copies can be created successfully

4. **`test_pretest_03_django_db_connection`**
   - Verifies Django database connection works with temporary databases

**Database Integrity Tests:**
1. **`test_database_integrity_check_tables`**
   - Verifies all required tables exist in the test database
   - Checks for: `machine`, `machine_encdecconfiguration`, `machine_nnmodel`
   - Checks for 158 `Machine_*_DataInputLines` and 158 `Machine_*_DataOutputLines` tables

2. **`test_database_integrity_check_machine_data`**
   - Verifies the machine table has 112 machines
   - Verifies machines have correct levels (1, 2, 3)

3. **`test_database_integrity_check_configuration_data`**
   - Verifies 2,514 EncDecConfigurations exist
   - Verifies 469 NNModels exist

4. **`test_database_integrity_check_data_lines_tables`**
   - Verifies data lines tables exist (input and output)
   - Verifies counts match for each type

5. **`test_database_integrity_check_constraints`**
   - Verifies no foreign key constraint violations
   - Runs SQLite integrity check

**Run only database integrity tests:**
```bash
python -m pytest "tests/Tests All AI modules/unit/test_database_integrity.py" -v
```

These tests should **always pass** first. If any fail, other tests will likely fail too.

### Basic Commands

**Note:** Run all commands from the project root directory.

#### Run All Tests
```bash
python -m pytest "tests/Tests All AI modules/unit" -v
```

#### Run Specific Test File
```bash
python -m pytest "tests/Tests All AI modules/unit/test_machine.py" -v
```

#### Run Specific Test
```bash
python -m pytest "tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_create_with_dataframe" -v
```

#### Run with Short Output
```bash
python -m pytest "tests/Tests All AI modules/unit" --tb=short -q
```

### Test Execution Options

#### Stop After First Failure
```bash
python -m pytest "tests/Tests All AI modules/unit" -x
```

#### Stop After N Failures
```bash
python -m pytest "tests/Tests All AI modules/unit" --maxfail=5
```

#### Run Tests in Parallel
```bash
python -m pytest "tests/Tests All AI modules/unit" -n auto
```

#### Show Only Test Results (No Details)
```bash
python -m pytest "tests/Tests All AI modules/unit" --tb=no -q
```

#### Run with Coverage
```bash
python -m pytest "tests/Tests All AI modules/unit" --cov=ML --cov-report=html
```

## Fixtures

The testing system provides several important fixtures:

### Available Fixtures:
- `db_cleanup`: Automatic database cleanup
- `simple_dataframe`: Basic test dataframe
- `numeric_dataframe`: Numeric-only test dataframe
- `mixed_dataframe`: Mixed data types test dataframe
- `iris_dataframe`: Iris flowers dataset from CSV file
- `columns_datatype`: Standard column datatype mapping
- `columns_description`: Standard column description mapping
- `test_machine_name`: Unique test machine name generator
- `machine_factory`: Factory for creating test machines
- `machine_with_all_configs`: Get existing machine with all configurations ready
- `logger`: Logger instance for tests

### Database Fixtures

#### `test_database`
Creates a temporary copy of the test database for Django ORM access.
```python
@pytest.mark.django_db
def test_something(test_database):
    # test_database contains the path to temporary database
    # Django is configured to use this database
    pass
```

#### `test_database_direct`
Provides direct SQLite access (bypasses Django ORM).
```python
def test_something(test_database_direct):
    import sqlite3
    conn = sqlite3.connect(test_database_direct)
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM machine LIMIT 1")
    result = cursor.fetchone()
    conn.close()
```

#### `test_database_with_verification`
Enhanced version that includes database content verification.
```python
@pytest.mark.django_db
def test_something(test_database_with_verification):
    # Database is verified to contain expected content
    pass
```

#### `simple_dataframe`
Minimal test DataFrame for basic tests.
```python
def test_something(simple_dataframe):
    # simple_dataframe contains sample test data
    pass
```

#### `numeric_dataframe`
Numeric-only DataFrame for numeric data tests.
```python
def test_something(numeric_dataframe):
    # numeric_dataframe contains numeric test data
    pass
```

#### `machine_factory`
Factory to create test machines.
```python
def test_something(machine_factory):
    machine = machine_factory(name="test_machine", dataframe=my_df)
    # machine is now ready for testing
```

#### `iris_dataframe`
Loads the Iris flowers dataset from CSV file.
```python
def test_something(iris_dataframe):
    # iris_dataframe contains Iris dataset with columns:
    # SepalLengthCm, SepalWidthCm, PetalLengthCm, PetalWidthCm, Species
    pass
```

#### `machine_with_all_configs`
Gets an existing machine from the test database with all configurations (MDC, ICI, FEC, EncDec) already set up.
```python
@pytest.mark.django_db
def test_something(machine_with_all_configs):
    machine = machine_with_all_configs
    # Machine already has MDC, ICI, FEC, EncDec configured
    # Ready for testing without setup
```

#### `use_test_database_copy`
Creates a temporary copy of the test database for direct SQLite access (bypasses Django ORM).
```python
def test_something(use_test_database_copy):
    import sqlite3
    conn = sqlite3.connect(use_test_database_copy)
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM machine LIMIT 1")
    result = cursor.fetchone()
    conn.close()
```

### Test Markers

#### `@pytest.mark.django_db`
**Automatically receives a temporary copy of the test database!**
```python
@pytest.mark.django_db
def test_something():
    # This test automatically gets a copy of start_set_databases.sqlite3
    machine = Machine.objects.get(id=1)
    assert machine is not None
```

#### `@pytest.mark.parametrize`
Run the same test with different parameters.
```python
@pytest.mark.parametrize("machine_level", [1, 2, 3])
def test_something(machine_level):
    # Test runs with each machine_level value
    pass
```

## Test Categories

### Unit Tests
- Test individual functions and methods
- Use mocks where appropriate
- Fast execution
- Isolated from external dependencies

### Integration Tests
- Test component interactions
- Use real database (with cleanup)
- Test end-to-end workflows
- May be slower than unit tests

### Specific Test Files

### 1. Encoder/Decoder Tests (`test_encdec.py`)
Tests encoding and decoding of data for neural networks.

### 2. Feature Engineering Tests (`test_feature_engineering_configuration.py`)
Tests feature engineering configuration management.

### 3. Input Columns Importance Tests (`test_inputs_columns_importance.py`)
Tests importance evaluation for input columns.

### 4. EAML DB Models Tests (`test_eaml_db_models.py`)
Tests the database models wrapper (EasyAutoMLDBModels).

### 5. Machine Tests (`test_machine.py`)
Comprehensive tests for the Machine class including:
- Machine creation and configuration
- Data lines operations (input/output)
- Machine copying and deletion
- Configuration management

### 5a. Machine Workflow Tests (`test_machine_1.py`)
Complete machine workflow tests:
- Create machine from CSV file
- Test machine properties
- Create all configurations
- Run training
- Test solving

### 5b. MachineEasyAutoML with Experimenter Tests (`test_machine_2.py`)
Tests for MachineEasyAutoML using Experimenter:
- Create SimpleExperimenter
- Create MachineEasyAutoML with experimenter
- Test predictions before training (using experimenter only)
- Train the machine
- Test predictions after training (using trained model)
- Compare results and verify improvement

### 6. Machine Data Configuration Tests (`test_machine_data_configuration.py`)
Tests for data configuration handling.

### 7. Machine EasyAutoML Tests (`test_machine_easy_automl.py`)
Tests the easy-to-use AutoML API.

### 8. Neural Network Configuration Tests (`test_nn_configuration.py`)
Tests for neural network configuration.

### 9. Neural Network Engine Tests (`test_nn_engine.py`)
Tests the neural network training and inference engine.

### 10. Solution Finder Tests (`test_solution_finder.py`)
Tests for solution optimization algorithms.

### 11. Solution Score Tests (`test_solution_score.py`)
Tests for solution scoring and evaluation.

### 12. Salaries Prediction Tests (`test_salaries_prediction.py`)
Complete workflow tests for salaries prediction dataset:
- Create machine from salaries prediction CSV file
- Create all machine configurations
- Run training
- Solve specific rows (607-608) from the CSV file

### 13. Database Integrity Tests (`test_database_integrity.py`)
Pre-test verification of database structure and content:
- Django models import verification
- Django models relationships verification
- Database copy creation verification
- Django DB connection verification
- Database integrity checks (tables, data, constraints)

## Understanding Test Failures

### Common Error Messages

#### "no such table: user"
- **Cause**: User table not created in test database
- **Solution**: The test database should already have the user table. Check that the test database file is properly generated.

#### "no such table: machine"
- **Cause**: Machine table not accessible
- **Solution**: The temporary database copy might have issues. Check that the source database has the machine table.

#### "ForeignKey constraint failed"
- **Cause**: Missing related data in the database
- **Solution**: The test database should have complete data with all relationships intact.

#### "Database is locked"
- **Cause**: Multiple tests trying to access the same temporary database
- **Solution**: Each test should get its own temporary copy (this is automatic).

## Best Practices

### 1. Test Independence
Each test should be independent and not rely on execution order.

### 2. Database Isolation
- Never modify the original test database directly
- Each test gets its own temporary copy
- Cleanup is automatic

### 3. Test Data
- Use provided fixtures for consistent test data
- Use descriptive names for test machines (prefixed with `__TEST_UNIT__`)
- Clean up test data after each test

### 4. Error Messages
- Write descriptive error messages
- Use assert statements with helpful messages
- Test edge cases and error conditions

### 5. Performance
- Fast tests run frequently
- Slow tests can be run less often
- Use `--maxfail` to stop after first few failures during development

## Configuration

Tests are configured via `pytest.ini` (located in project root):
- Test discovery patterns
- Markers for test categorization
- Warning filters
- Output formatting

The `pytest.ini` file contains:
```ini
[pytest]
# Test discovery patterns
python_files = tests.py test_*.py *_tests.py
python_classes = Test*
python_functions = test_*

# Test paths
testpaths = tests/Tests All AI modules/unit

# Additional options
addopts = 
    --verbose
    --strict-markers
    --tb=long
    --showlocals
    --full-trace
    -p no:warnings
    --no-migrations

# Markers
markers =
    django_db: Tests that require database access
    slow: Slow running tests
    integration: Integration tests
    unit: Unit tests
```

**Note:** Tests are located in `tests/Tests All AI modules/unit/`. You can run them using the full path:
```bash
python -m pytest "tests/Tests All AI modules/unit/" -v
```

## Troubleshooting

### Issue: Tests can't find the database
**Solution**: Ensure `start_set_databases.sqlite3` exists in the project root

### Issue: "ValueError: Related model cannot be resolved"
**Solution**: Models need to be properly registered. Check `tests/Tests All AI modules/conftest.py` for model imports.

### Issue: Import errors in tests
**Solution**: Check that the ML modules are available and Django is properly configured. Ensure you're running from the project root directory.

### Issue: Database lock errors
**Solution**: Tests are running in parallel and conflict. Try running with `-n 1` to run sequentially.

## Advanced Usage

### Running Specific Test Categories

#### Run only Machine tests
```bash
python -m pytest "tests/Tests All AI modules/unit/test_machine.py" -v
```

#### Run only Neural Network tests
```bash
python -m pytest "tests/Tests All AI modules/unit/test_nn_engine.py" "tests/Tests All AI modules/unit/test_nn_configuration.py" -v
```

### Test Coverage

#### Generate coverage report
```bash
python -m pytest "tests/Tests All AI modules/unit" --cov=ML --cov-report=term-missing
```

#### Generate HTML coverage report
```bash
python -m pytest "tests/Tests All AI modules/unit" --cov=ML --cov-report=html
# Open htmlcov/index.html in browser
```

### Debugging Tests

#### Run with Python debugger
```bash
python -m pytest "tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_something" --pdb
```

#### Print debug output
```bash
python -m pytest "tests/Tests All AI modules/unit" -s -v
```

## Continuous Integration

### Running Tests in CI

The test system is designed to work in CI environments:

```yaml
# Example GitHub Actions
- name: Run Tests
  run: |
    python -m pytest "tests/Tests All AI modules/unit" --tb=short -v
```

### Pre-commit Hooks

You can add pre-commit hooks to run tests automatically:

```yaml
# .pre-commit-config.yaml
repos:
  - repo: local
    hooks:
      - id: pytest
        name: pytest
        entry: python -m pytest "tests/Tests All AI modules/unit" --tb=short -q
        language: system
        pass_filenames: false
```

## Migration from Old Tests

The old test files in `/ML/_tests_/` have been removed and replaced with:
- Modern pytest-based tests
- Better organization and structure
- Comprehensive coverage of all ML modules
- Improved maintainability and readability

All tests are now located in `tests/Tests All AI modules/unit/` with:
- Consistent naming conventions
- Modular test structure
- Reusable fixtures
- Comprehensive documentation

## Summary

The unit testing system provides:
1. ✅ Automatic database copying for each test
2. ✅ Test isolation through temporary databases
3. ✅ Realistic test data from 112 trained machines
4. ✅ Cleanup after each test
5. ✅ Flexible test execution options
6. ✅ Comprehensive fixture system

**Key Takeaway**: Every test with `@pytest.mark.django_db` automatically gets a populated copy of `start_set_databases.sqlite3` for realistic testing!
