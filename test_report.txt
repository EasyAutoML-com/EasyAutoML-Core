============================= test session starts =============================
platform win32 -- Python 3.11.9, pytest-8.4.2, pluggy-1.6.0 -- C:\Users\Administrator\Documents\GITHUB-APS\REPO-APS\.venv\Scripts\python.exe
cachedir: .pytest_cache
django: version: 5.2.3
rootdir: C:\Users\Administrator\Documents\Repo-EAML-Core
configfile: pytest.ini
plugins: anyio-4.9.0, langsmith-0.4.1, django-4.11.1
collecting ... collected 204 items

tests/Tests All AI modules/unit/test_database_integrity.py::test_pretest_03_django_db_connection PASSED [  0%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_init PASSED [  0%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_machine_model PASSED [  1%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_user_model PASSED [  1%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_team_model PASSED [  2%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_logger PASSED [  2%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_logger_functionality PASSED [  3%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_all_models_access PASSED [  3%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_objects_interface PASSED [  4%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_queryset_methods PASSED [  4%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_field_access PASSED [  5%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_singleton_behavior PASSED [  5%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_meta_access PASSED [  6%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_string_representation PASSED [  6%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_verbose_names PASSED [  7%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_ordering PASSED [  7%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_permissions PASSED [  8%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_constraints PASSED [  8%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_indexes PASSED [  9%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_unique_together PASSED [  9%]
tests/Tests All AI modules/unit/test_eaml_db_models.py::TestEasyAutoMLDBModels::test_eaml_db_models_model_index_together PASSED [ 10%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_create_configuration PASSED [ 10%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_load_configuration PASSED [ 11%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_encode_for_ai PASSED [ 11%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_decode_from_ai PASSED [ 12%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_encode_decode_roundtrip PASSED [ 12%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_save_configuration PASSED [ 13%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_configuration_serialization PASSED [ 13%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_invalid_dataframe_type PASSED [ 14%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_with_different_data_types PASSED [ 14%]
tests/Tests All AI modules/unit/test_encdec.py::TestEncDec::test_encdec_get_encoded_for_ai_columns_names_by_the_pre_encoded_column_name PASSED [ 15%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_create_minimum_configuration PASSED [ 15%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_load_configuration PASSED [ 16%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_save_configuration PASSED [ 16%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_get_all_column_datas_infos PASSED [ 17%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_fet_activation_logic PASSED [ 17%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_cost_per_columns PASSED [ 18%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_invalid_parameters PASSED [ 18%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_with_different_data_types PASSED [ 19%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_find_delay_tracking PASSED [ 19%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_set_this_fec_in_columns_configuration PASSED [ 20%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_store_this_fec_to_fet_list_configuration PASSED [ 20%]
tests/Tests All AI modules/unit/test_feature_engineering_configuration.py::TestFeatureEngineeringConfiguration::test_fec_get_column_data_overview_information PASSED [ 21%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_create_minimum_configuration PASSED [ 21%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_load_configuration PASSED [ 22%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_save_configuration PASSED [ 22%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_importance_evaluation_structure PASSED [ 23%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_input_output_columns_separation PASSED [ 23%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_find_delay_tracking PASSED [ 24%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_invalid_parameters PASSED [ 24%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_with_different_data_types PASSED [ 25%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_minimum_configuration_equal_importance PASSED [ 25%]
tests/Tests All AI modules/unit/test_inputs_columns_importance.py::TestInputsColumnsImportance::test_ici_with_numeric_data PASSED [ 25%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_create_with_dataframe PASSED [ 26%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_save_and_load_by_id PASSED [ 26%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_load_by_name PASSED [ 27%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_get_random_dataframe PASSED [ 27%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_config_ready_flags PASSED [ 28%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_clear_config_methods PASSED [ 28%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_repr PASSED [ 29%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_with_machine_level PASSED [ 29%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_access_check PASSED [ 30%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_get_last_id PASSED [ 30%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_create_both_tables PASSED [ 31%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_read PASSED [ 31%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_update PASSED [ 32%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_delete_all PASSED [ 32%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_append PASSED [ 33%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_lines_mark PASSED [ 33%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_read PASSED [ 34%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_append PASSED [ 34%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_mark PASSED [ 35%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_mark_all_IsForLearning_as_IsLearned PASSED [ 35%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_update PASSED [ 36%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_input_lines_count PASSED [ 36%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_output_lines_read PASSED [ 37%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_output_lines_append PASSED [ 37%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_output_lines_mark PASSED [ 38%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_output_lines_update PASSED [ 38%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_data_output_lines_count PASSED [ 39%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_copy PASSED [ 39%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_is_this_machine_exist_and_authorized PASSED [ 40%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_store_error PASSED [ 40%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_store_warning PASSED [ 41%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_get_machine_overview_information PASSED [ 41%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_user_dataframe_format_then_save_in_db PASSED [ 42%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_get_all_encoded_for_ai_columns_names_by_the_pre_encoded_column_name PASSED [ 42%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_get_list_of_columns_name PASSED [ 43%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_scale_loss_to_user_loss PASSED [ 43%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_get_count_of_rows_per_isforflags PASSED [ 44%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_feature_engineering_budget PASSED [ 44%]
tests/Tests All AI modules/unit/test_machine.py::TestMachine::test_machine_with_test_database_content PASSED [ 45%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_create_configuration PASSED [ 45%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_load_configuration PASSED [ 46%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_dataframe_pre_encode PASSED [ 46%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_dataframe_post_decode PASSED [ 47%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_save_configuration PASSED [ 47%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_column_statistics PASSED [ 48%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_json_column_handling PASSED [ 48%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_missing_values_handling PASSED [ 49%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_force_inputs_outputs PASSED [ 49%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_errors_and_warnings PASSED [ 50%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_verify_compatibility_additional_dataframe PASSED [ 50%]
tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_get_parent_of_extended_column FAILED [ 50%]

================================== FAILURES ===================================
_____ TestMachineDataConfiguration.test_mdc_get_parent_of_extended_column _____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x000002418E3877E0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

cls        = <class '_pytest.runner.CallInfo'>
duration   = Duration(start=Instant(time=1763743263.760705, perf_count=135481.9449786),
         stop=Instant(time=1763743397.5872974, perf_count=135615.7726502))
excinfo    = <ExceptionInfo AssertionError('assert False\n +  where False = isinstance(None, str)') tblen=24>
func       = <function call_and_report.<locals>.<lambda> at 0x000002418E3877E0>
instant    = Instant(time=1763743263.760705, perf_count=135481.9449786)
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
when       = 'call'

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )

item       = <Function test_mdc_get_parent_of_extended_column>
kwds       = {}
runtest_hook = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
kwargs     = {'item': <Function test_mdc_get_parent_of_extended_column>}
self       = <HookCaller 'pytest_runtest_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000024157274310>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = False
hook_name  = 'pytest_runtest_call'
kwargs     = {'item': <Function test_mdc_get_parent_of_extended_column>}
methods    = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FAF90>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FB290>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002410D7D7F10>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000024157274310>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_mdc_get_parent_of_extended_column>]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
exception  = AssertionError('assert False\n +  where False = isinstance(None, str)')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x000002418CD6F790>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FAF90>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FB290>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002410D7D7F10>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x000002418CD6F790>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x000002418CD6F5B0>,
 <generator object run_old_style_hookwrapper at 0x000002418CD5C820>,
 <generator object pytest_runtest_call at 0x000002418CD6F790>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_mdc_get_parent_of_extended_column>]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
exception  = AssertionError('assert False\n +  where False = isinstance(None, str)')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x000002418CD6F790>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FAF90>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FB290>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002410D7D7F10>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x000002418CD6F790>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x000002418CD6F5B0>,
 <generator object run_old_style_hookwrapper at 0x000002418CD5C820>,
 <generator object pytest_runtest_call at 0x000002418CD6F790>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x000002410D7D7F10>
item = <Function test_mdc_get_parent_of_extended_column>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")
    
        with self._runtest_for(item, "call"):
>           yield

item       = <Function test_mdc_get_parent_of_extended_column>
self       = <_pytest.logging.LoggingPlugin object at 0x000002410D7D7F10>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\logging.py:850: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_mdc_get_parent_of_extended_column>]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
exception  = AssertionError('assert False\n +  where False = isinstance(None, str)')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x000002418CD6F790>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FAF90>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FB290>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002410D7D7F10>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x000002418CD6F790>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x000002418CD6F5B0>,
 <generator object run_old_style_hookwrapper at 0x000002418CD5C820>,
 <generator object pytest_runtest_call at 0x000002418CD6F790>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io...._io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_mdc_get_parent_of_extended_column>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

item       = <Function test_mdc_get_parent_of_extended_column>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FAF90>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FB290>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\capture.py:900: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_mdc_get_parent_of_extended_column>]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
exception  = AssertionError('assert False\n +  where False = isinstance(None, str)')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x000002418CD6F790>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FAF90>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FB290>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002410D7D7F10>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x000002418CD6F790>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x000002418CD6F5B0>,
 <generator object run_old_style_hookwrapper at 0x000002418CD5C820>,
 <generator object pytest_runtest_call at 0x000002418CD6F790>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_mdc_get_parent_of_extended_column>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

args       = [<Function test_mdc_get_parent_of_extended_column>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x0000024218D25A00>
teardown   = <generator object pytest_runtest_call at 0x000002418EA4FB40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x0000024218D25A00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

__tracebackhide__ = True
exc        = AssertionError('assert False\n +  where False = isinstance(None, str)')
self       = <pluggy._result.Result object at 0x0000024218D25A00>
tb         = <traceback object at 0x0000024218D27B80>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_result.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_mdc_get_parent_of_extended_column>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """
    
        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

args       = [<Function test_mdc_get_parent_of_extended_column>]
hook_impl  = <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>
hook_name  = 'pytest_runtest_call'
result     = <pluggy._result.Result object at 0x0000024218D25A00>
teardown   = <generator object pytest_runtest_call at 0x000002418EA4FB40>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

__tracebackhide__ = True
args       = [<Function test_mdc_get_parent_of_extended_column>]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
exception  = AssertionError('assert False\n +  where False = isinstance(None, str)')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x000002418CD6F790>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FAF90>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FB290>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002410D7D7F10>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x000002418CD6F790>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x000002418CD6F5B0>,
 <generator object run_old_style_hookwrapper at 0x000002418CD5C820>,
 <generator object pytest_runtest_call at 0x000002418CD6F790>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mdc_get_parent_of_extended_column>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)
    
        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)
    
        try:
>           return (yield)
                    ^^^^^

item       = <Function test_mdc_get_parent_of_extended_column>
xfailed    = None

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\skipping.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Doc...tIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_mdc_get_parent_of_extended_column>]
caller_kwargs = {'item': <Function test_mdc_get_parent_of_extended_column>}
exception  = AssertionError('assert False\n +  where False = isinstance(None, str)')
firstresult = False
function_gen = <generator object pytest_runtest_call at 0x000002418CD6F790>
hook_impl  = <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\threadexception.py'>>,
 <HookImpl plugin_name='unraisableexception', plugin=<module '_pytest.unraisableexception' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\unraisableexception.py'>>,
 <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\runner.py'>>,
 <HookImpl plugin_name='skipping', plugin=<module '_pytest.skipping' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\skipping.py'>>,
 <HookImpl plugin_name='langsmith_plugin', plugin=<module 'langsmith.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\langsmith\\pytest_plugin.py'>>,
 <HookImpl plugin_name='capturemanager', plugin=<CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FAF90>' mode='r+' encoding='utf-8'>> err=<FDCapture 2 oldfd=7 _state='suspended' tmpfile=<_io.TextIOWrapper name='<tempfile._TemporaryFileWrapper object at 0x000002415C5FB290>' mode='r+' encoding='utf-8'>> in_=<FDCapture 0 oldfd=3 _state='started' tmpfile=<_io.TextIOWrapper name='nul' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>,
 <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x000002410D7D7F10>>]
hook_name  = 'pytest_runtest_call'
res        = <generator object pytest_runtest_call at 0x000002418CD6F790>
result     = []
results    = []
teardown   = <generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>
teardowns  = [<generator object LoggingPlugin.pytest_runtest_call at 0x000002418CD6F4C0>,
 <generator object CaptureManager.pytest_runtest_call at 0x000002418CD6F5B0>,
 <generator object run_old_style_hookwrapper at 0x000002418CD5C820>,
 <generator object pytest_runtest_call at 0x000002418CD6F790>]

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mdc_get_parent_of_extended_column>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

item       = <Function test_mdc_get_parent_of_extended_column>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\runner.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_mdc_get_parent_of_extended_column>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

self       = <Function test_mdc_get_parent_of_extended_column>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:1671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_mdc_get_parent_of_extended_column>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
kwargs     = {'pyfuncitem': <Function test_mdc_get_parent_of_extended_column>}
self       = <HookCaller 'pytest_pyfunc_call'>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_hooks.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x0000024157274310>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
kwargs = {'pyfuncitem': <Function test_mdc_get_parent_of_extended_column>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

firstresult = True
hook_name  = 'pytest_pyfunc_call'
kwargs     = {'pyfuncitem': <Function test_mdc_get_parent_of_extended_column>}
methods    = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
self       = <_pytest.config.PytestPluginManager object at 0x0000024157274310>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mdc_get_parent_of_extended_column>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results
    
            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")
    
        if exception is not None:
>           raise exception

__tracebackhide__ = True
args       = [<Function test_mdc_get_parent_of_extended_column>]
caller_kwargs = {'pyfuncitem': <Function test_mdc_get_parent_of_extended_column>}
exception  = AssertionError('assert False\n +  where False = isinstance(None, str)')
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS...from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mdc_get_parent_of_extended_column>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e
    
                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)
    
                        next(function_gen)  # first yield
                        teardowns.append(function_gen)
    
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

__tracebackhide__ = True
args       = [<Function test_mdc_get_parent_of_extended_column>]
caller_kwargs = {'pyfuncitem': <Function test_mdc_get_parent_of_extended_column>}
exception  = AssertionError('assert False\n +  where False = isinstance(None, str)')
firstresult = True
hook_impl  = <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\_pytest\\python.py'>>,
 <HookImpl plugin_name='anyio', plugin=<module 'anyio.pytest_plugin' from 'C:\\Users\\Administrator\\Documents\\GITHUB-APS\\REPO-APS\\.venv\\Lib\\site-packages\\anyio\\pytest_plugin.py'>>]
hook_name  = 'pytest_pyfunc_call'
res        = None
result     = None
results    = []
teardowns  = []

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\pluggy\_callers.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_mdc_get_parent_of_extended_column>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

funcargs   = {'_dj_autoclear_mailbox': None,
 '_django_clear_site_cache': None,
 '_django_db_marker': None,
 '_django_set_urlconf': None,
 '_django_setup_unittest': None,
 '_fail_for_invalid_template_variable': None,
 '_live_server_helper': None,
 '_template_string_if_invalid_marker': None,
 'columns_datatype': {'feature1': <DatasetColumnDataType.FLOAT: 2>,
                      'feature2': <DatasetColumnDataType.FLOAT: 2>,
                      'feature3': <DatasetColumnDataType.LABEL: 3>,
                      'target': <DatasetColumnDataType.FLOAT: 2>},
 'columns_description': {'feature1': 'First feature',
                         'feature2': 'Second feature',
                         'feature3': 'Third categorical feature',
                         'target': 'Target variable'},
 'db_cleanup': None,
 'django_db_blocker': <pytest_django.plugin.DjangoDbBlocker object at 0x000002415C5EA790>,
 'django_test_environment': None,
 'monkeypatch': <_pytest.monkeypatch.MonkeyPatch object at 0x000002421E001710>,
 'request': <FixtureRequest for <Function test_mdc_get_parent_of_extended_column>>,
 'simple_dataframe':     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533}
pyfuncitem = <Function test_mdc_get_parent_of_extended_column>
testargs   = {'columns_datatype': {'feature1': <DatasetColumnDataType.FLOAT: 2>,
                      'feature2': <DatasetColumnDataType.FLOAT: 2>,
                      'feature3': <DatasetColumnDataType.LABEL: 3>,
                      'target': <DatasetColumnDataType.FLOAT: 2>},
 'columns_description': {'feature1': 'First feature',
                         'feature2': 'Second feature',
                         'feature3': 'Third categorical feature',
                         'target': 'Target variable'},
 'db_cleanup': None,
 'simple_dataframe':     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533}
testfunction = <bound method TestMachineDataConfiguration.test_mdc_get_parent_of_extended_column of <unit.test_machine_data_configuration.TestMachineDataConfiguration object at 0x000002418CA20CD0>>

..\GITHUB-APS\REPO-APS\.venv\Lib\site-packages\_pytest\python.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unit.test_machine_data_configuration.TestMachineDataConfiguration object at 0x000002418CA20CD0>
db_cleanup = None
simple_dataframe =     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1...314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533
columns_datatype = {'feature1': <DatasetColumnDataType.FLOAT: 2>, 'feature2': <DatasetColumnDataType.FLOAT: 2>, 'feature3': <DatasetColumnDataType.LABEL: 3>, 'target': <DatasetColumnDataType.FLOAT: 2>}
columns_description = {'feature1': 'First feature', 'feature2': 'Second feature', 'feature3': 'Third categorical feature', 'target': 'Target variable'}

    @pytest.mark.django_db
    def test_mdc_get_parent_of_extended_column(self, db_cleanup, simple_dataframe, columns_datatype, columns_description):
        """
        Test Getting Parent of Extended Column
    
        WHAT THIS TEST DOES:
        - Tests the method that finds the parent column of an extended column
        - Verifies that the method correctly identifies parent-child relationships
        - Tests edge cases and error handling
    
        WHY THIS TEST IS IMPORTANT:
        - This method is used to track column relationships in complex data structures
        - It helps understand how columns are extended during preprocessing
        - It's essential for maintaining data lineage
    
        WHAT WE'RE TESTING:
        - Method correctly identifies parent columns
        - Method handles non-extended columns
        - Method handles edge cases (None inputs, invalid column names)
        - Method returns appropriate results
    
        TEST STEPS:
        1. Create MDC configuration
        2. Test with extended column names
        3. Test with non-extended column names
        4. Test edge cases
        """
        machine = Machine(
            "__TEST_UNIT__mdc_parent",
            simple_dataframe,
            decimal_separator=".",
            date_format="%Y-%m-%d",
            machine_create_user_id=self._get_admin_user().id,
            disable_foreign_key_checking=True
        )
        machine.save_machine_to_db()
    
        mdc = MachineDataConfiguration(
            machine=machine,
            user_dataframe_for_create_cfg=simple_dataframe,
            columns_type_user_df=columns_datatype,
            columns_description_user_df=columns_description,
            decimal_separator=".",
            date_format="%Y-%m-%d"
        )
    
        # Test with regular column name (should return None or same name)
        regular_column = list(simple_dataframe.columns)[0]
        parent = mdc.get_parent_of_extended_column(regular_column)
        assert parent is None or isinstance(parent, str)
    
        # Test with extended column name (if any exist)
        # This would depend on the actual column structure
        try:
            extended_column = f"{regular_column}_extended"
            parent = mdc.get_parent_of_extended_column(extended_column)
            assert parent is None or isinstance(parent, str)
        except Exception:
            # May not have extended columns in simple test data
            pass
    
        # Test with None input - should handle gracefully
        try:
            parent = mdc.get_parent_of_extended_column(None)
            assert parent is None
        except ValueError:
            # Expected behavior - None is not a valid column name
            pass
    
        # Test with empty string - should handle gracefully
        try:
            parent = mdc.get_parent_of_extended_column("")
>           assert isinstance(parent, str)
E           assert False
E            +  where False = isinstance(None, str)

columns_datatype = {'feature1': <DatasetColumnDataType.FLOAT: 2>,
 'feature2': <DatasetColumnDataType.FLOAT: 2>,
 'feature3': <DatasetColumnDataType.LABEL: 3>,
 'target': <DatasetColumnDataType.FLOAT: 2>}
columns_description = {'feature1': 'First feature',
 'feature2': 'Second feature',
 'feature3': 'Third categorical feature',
 'target': 'Target variable'}
db_cleanup = None
extended_column = 'feature1_extended'
machine    = <machine:904:__TEST_UNIT__mdc_parent>
mdc        = <ML.MachineDataConfiguration.MachineDataConfiguration object at 0x000002418E2FBBD0>
parent     = None
regular_column = 'feature1'
self       = <unit.test_machine_data_configuration.TestMachineDataConfiguration object at 0x000002418CA20CD0>
simple_dataframe =     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533

tests\Tests All AI modules\unit\test_machine_data_configuration.py:633: AssertionError
---------------------------- Captured stderr call -----------------------------
[31mERROR   |<frozen runpy>|Invalid date_format: '%Y-%m-%d'. Must be one of ('DMY', 'MDY', 'YMD')[0m
[31mERROR   |<frozen runpy>|Invalid date_format: '%Y-%m-%d'. Must be one of ('DMY', 'MDY', 'YMD')[0m
[34mDEBUG   |<frozen runpy>|Creation __TEST_UNIT__mdc_parent by Dataset [0m
[34mDEBUG   |<frozen runpy>|Creating DFR from dataframe , shape:(20, 4)[0m
[34mDEBUG   |<frozen runpy>|Analysing column : feature1 -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : feature2 -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Analysing column : feature3 -> DatasetColumnDataType.LABEL[0m
[34mDEBUG   |<frozen runpy>|Analysing column : target -> DatasetColumnDataType.FLOAT[0m
[34mDEBUG   |<frozen runpy>|Reformat DF : 20 rows X 4 cols [0m
[31mERROR   |<frozen runpy>|Invalid date_format: '%Y-%m-%d'. Must be one of ('DMY', 'MDY', 'YMD')[0m
[34mDEBUG   |<frozen runpy>|Creation __TEST_UNIT__mdc_parent by DFR [0m
[34mDEBUG   |<frozen runpy>|Creation MachineDataConfiguration from user dataset[0m
[34mDEBUG   |<frozen runpy>|MDC saving configuration full[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine: Empty machine> on disk[0m
[34mDEBUG   |<frozen runpy>|Create_data_tables for <machine:904:__TEST_UNIT__mdc_parent> started[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataInputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataInputLines" (
	"Line_ID" BIGINT, 
	feature1 FLOAT, 
	feature2 FLOAT, 
	feature3 TEXT, 
	"IsForLearning" BOOLEAN, 
	"IsForSolving" BOOLEAN, 
	"IsForEvaluation" BOOLEAN, 
	"IsLearned" BOOLEAN, 
	"IsSolved" BOOLEAN
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data input lines was appended. First_new_row_id:1 with arguments:{}[0m
[31mERROR   |<frozen runpy>|There was a problem during dataframe.to_sql execution in table 'Machine_904_DataOutputLines' : (sqlite3.OperationalError) database is locked
[SQL: 
CREATE TABLE "Machine_904_DataOutputLines" (
	"Line_ID" BIGINT, 
	target FLOAT
)

]
(Background on this error at: https://sqlalche.me/e/20/e3q8) [0m
[34mDEBUG   |<frozen runpy>|machine data output lines was appended[0m
[34mDEBUG   |<frozen runpy>|data_lines_appended     feature1  feature2 feature3    target
0   0.496714  1.465649        C  0.343618
1  -0.138264 -0.225776        B -1.763040
2   0.647689  0.067528        B  0.324084
3   1.523030 -1.424748        B -0.385082
4  -0.234153 -0.544383        B -0.676922
5  -0.234137  0.110923        B  0.611676
6   1.579213 -1.150994        B  1.031000
7   0.767435  0.375698        C  0.931280
8  -0.469474 -0.600639        C -0.839218
9   0.542560 -0.291694        B -0.309212
10 -0.463418 -0.601707        C  0.331263
11 -0.465730  1.852278        A  0.975545
12  0.241962 -0.013497        B -0.479174
13 -1.913280 -1.057711        A -0.185659
14 -1.724918  0.822545        A -1.106335
15 -0.562288 -1.220844        B -1.196207
16 -1.012831  0.208864        C  0.812526
17  0.314247 -1.959670        A  1.356240
18 -0.908024 -1.328186        B -0.072010
19 -1.412304  0.196861        A  1.003533 rows, with kwarg:{} [0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_UNIT__mdc_parent> on disk[0m
[34mDEBUG   |<frozen runpy>|Machine created and saved : <machine:904:__TEST_UNIT__mdc_parent>[0m
[34mDEBUG   |<frozen runpy>|Saving <machine:904:__TEST_UNIT__mdc_parent> on disk[0m
[34mDEBUG   |<frozen runpy>|Saving Django Machine model <machine:904:__TEST_UNIT__mdc_parent> on disk[0m
[34mDEBUG   |<frozen runpy>|Creation MachineDataConfiguration from user dataset[0m
[31mERROR   |<frozen runpy>|The json column tree does not contain a 'feature1' column[0m
[31mERROR   |<frozen runpy>|The dataframe does not contain a 'feature1_extended' column[0m
[31mERROR   |<frozen runpy>|The json column tree does not contain a 'feature1_extended' column[0m
[31mERROR   |<frozen runpy>|The dataframe does not contain a 'None' column[0m
[31mERROR   |<frozen runpy>|The json column tree does not contain a 'None' column[0m
[31mERROR   |<frozen runpy>|The dataframe does not contain a '' column[0m
[31mERROR   |<frozen runpy>|The json column tree does not contain a '' column[0m
=========================== short test summary info ===========================
FAILED tests/Tests All AI modules/unit/test_machine_data_configuration.py::TestMachineDataConfiguration::test_mdc_get_parent_of_extended_column - assert False
 +  where False = isinstance(None, str)
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!
================= 1 failed, 103 passed in 10454.22s (2:54:14) =================
